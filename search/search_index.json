{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyCap PyCap is an interface to the REDCap Application Programming Interface (API). PyCap is designed to be a minimal interface exposing all required and optional API parameters. Our hope is that it makes simple things easy & hard things possible. Installation Install the latest version with pip $ pip install PyCap If you want to load REDCap data into pandas dataframes, this will make sure you have pandas installed $ pip install PyCap [ pandas ] To install the bleeding edge version from the github repo, use the following $ pip install -e git+https://github.com/redcap-tools/PyCap.git#egg = PyCap Philosophy The REDCap API is pretty simple. There is no built-in search or pagination, for example. However, it does expose all the functionality required to build advanced data management services on top of the API. In the same way, PyCap is minimal by design. It doesn't do anything fancy behind the scenes and will not prevent you from shooting yourself in the foot. However, it should be very easy to understand and mentally-map PyCap functionality to the REDCap API. License PyCap is licensed under the MIT license . Citing If you use PyCap in your research, please consider citing the software: Burns, S. S., Browne, A., Davis, G. N., Rimrodt, S. L., & Cutting, L. E. PyCap (Version 1.0) [Computer Software]. Nashville, TN: Vanderbilt University and Philadelphia, PA: Childrens Hospital of Philadelphia. Available from https://github.com/redcap-tools/PyCap. doi:10.5281/zenodo.9917","title":"Home"},{"location":"#pycap","text":"PyCap is an interface to the REDCap Application Programming Interface (API). PyCap is designed to be a minimal interface exposing all required and optional API parameters. Our hope is that it makes simple things easy & hard things possible.","title":"PyCap"},{"location":"#installation","text":"Install the latest version with pip $ pip install PyCap If you want to load REDCap data into pandas dataframes, this will make sure you have pandas installed $ pip install PyCap [ pandas ] To install the bleeding edge version from the github repo, use the following $ pip install -e git+https://github.com/redcap-tools/PyCap.git#egg = PyCap","title":"Installation"},{"location":"#philosophy","text":"The REDCap API is pretty simple. There is no built-in search or pagination, for example. However, it does expose all the functionality required to build advanced data management services on top of the API. In the same way, PyCap is minimal by design. It doesn't do anything fancy behind the scenes and will not prevent you from shooting yourself in the foot. However, it should be very easy to understand and mentally-map PyCap functionality to the REDCap API.","title":"Philosophy"},{"location":"#license","text":"PyCap is licensed under the MIT license .","title":"License"},{"location":"#citing","text":"If you use PyCap in your research, please consider citing the software: Burns, S. S., Browne, A., Davis, G. N., Rimrodt, S. L., & Cutting, L. E. PyCap (Version 1.0) [Computer Software]. Nashville, TN: Vanderbilt University and Philadelphia, PA: Childrens Hospital of Philadelphia. Available from https://github.com/redcap-tools/PyCap. doi:10.5281/zenodo.9917","title":"Citing"},{"location":"quickstart/","text":"Quickstart PyCap makes it very simple to interact with the data stored in your REDCap projects from redcap import Project api_url = 'https://redcap.example.edu/api/' api_key = 'SomeSuperSecretAPIKeyThatNobodyElseShouldHave' project = Project ( api_url , api_key ) Export all the data data = project . export_records () Import all the data to_import = [{ 'record' : 'foo' , 'test_score' : 'bar' }] response = project . import_records ( to_import ) Import a file fname = 'something_to_upload.txt' with open ( fname , 'r' ) as fobj : project . import_file ( '1' , 'file' , fname , fobj ) Export a file content , headers = project . export_file ( '1' , 'file' ) with open ( headers [ 'name' ], 'w' ) as fobj : fobj . write ( content ) Delete a file try : project . delete_file ( '1' , 'file' ) except redcap . RedcapError : # Throws this if file wasn't successfully deleted pass except ValueError : # You screwed up and gave it a bad field name, etc pass","title":"Quick Start"},{"location":"quickstart/#quickstart","text":"PyCap makes it very simple to interact with the data stored in your REDCap projects from redcap import Project api_url = 'https://redcap.example.edu/api/' api_key = 'SomeSuperSecretAPIKeyThatNobodyElseShouldHave' project = Project ( api_url , api_key ) Export all the data data = project . export_records () Import all the data to_import = [{ 'record' : 'foo' , 'test_score' : 'bar' }] response = project . import_records ( to_import ) Import a file fname = 'something_to_upload.txt' with open ( fname , 'r' ) as fobj : project . import_file ( '1' , 'file' , fname , fobj ) Export a file content , headers = project . export_file ( '1' , 'file' ) with open ( headers [ 'name' ], 'w' ) as fobj : fobj . write ( content ) Delete a file try : project . delete_file ( '1' , 'file' ) except redcap . RedcapError : # Throws this if file wasn't successfully deleted pass except ValueError : # You screwed up and gave it a bad field name, etc pass","title":"Quickstart"},{"location":"using-in-app-or-package/","text":"Using PyCap in an app/package If you're using PyCap for a small script/ad-hoc data pull, then the Project class has the all the necessary functionality. Similarly, the Project class is a good choice if you need access to a wide array of functionality (export records, surveys, user, etc.). However, if you only are using one piece of the REDCap API, then you might want to consider using one of the more focused and simpler classes. For example, if all you want to do is export/import records from your project, then Records class can meet all of your needs, with it's Records.export_records and Records.import_records methods. In fact, these methods are exactly the same as the Project.export_records and Project.import_records methods. The Project class directly inherits them from the Records class. The benefit of using the Records class over the Project class in this case for your application or package is getting to use a simpler class (easy for the developer) and only having to depend on a simpler class (better for the app). For a full list of all Project subclasses, see the API Reference .","title":"Using PyCap in an app/package"},{"location":"using-in-app-or-package/#using-pycap-in-an-apppackage","text":"If you're using PyCap for a small script/ad-hoc data pull, then the Project class has the all the necessary functionality. Similarly, the Project class is a good choice if you need access to a wide array of functionality (export records, surveys, user, etc.). However, if you only are using one piece of the REDCap API, then you might want to consider using one of the more focused and simpler classes. For example, if all you want to do is export/import records from your project, then Records class can meet all of your needs, with it's Records.export_records and Records.import_records methods. In fact, these methods are exactly the same as the Project.export_records and Project.import_records methods. The Project class directly inherits them from the Records class. The benefit of using the Records class over the Project class in this case for your application or package is getting to use a simpler class (easy for the developer) and only having to depend on a simpler class (better for the app). For a full list of all Project subclasses, see the API Reference .","title":"Using PyCap in an app/package"},{"location":"api_reference/field_names/","text":"Field Names REDCap API methods for Project field names FieldNames ( Base ) Responsible for all API methods under 'Field Names' in the API Playground Source code in redcap/methods/field_names.py class FieldNames ( Base ): \"\"\"Responsible for all API methods under 'Field Names' in the API Playground\"\"\" # pylint: disable=redefined-builtin @overload def export_field_names ( self , field : str , format : str = \"json\" , df_kwargs : Optional [ Dict ] = None ) -> str : ... @overload def export_field_names ( self , field : None = None , format : str = \"json\" , df_kwargs : Optional [ Dict ] = None ) -> Union [ List [ Dict ], \"pd.DataFrame\" ]: ... def export_field_names ( self , field : Optional [ str ] = None , format : str = \"json\" , df_kwargs : Optional [ Dict ] = None , ): \"\"\" Export the project's export field names Args: field: Limit exported field name to this field (only single field supported). When not provided, all fields returned format: `'json'`, `'csv'`, `'xml'`, `'df'` Return the metadata in native objects, csv or xml. `'df'` will return a `pandas.DataFrame` df_kwargs: Passed to `pandas.read_csv` to control construction of returned DataFrame. by default `{'index_col': 'original_field_name'}` Returns: Union[str, List[Dict], \"pd.DataFrame\"]: Metadata structure for the project. Examples: >>> proj.export_field_names() [{'original_field_name': 'record_id', 'choice_value': '', 'export_field_name': 'record_id'}, {'original_field_name': 'field_1', 'choice_value': '', 'export_field_name': 'field_1'}, {'original_field_name': 'checkbox_field', 'choice_value': '1', 'export_field_name': 'checkbox_field___1'}, {'original_field_name': 'checkbox_field', 'choice_value': '2', 'export_field_name': 'checkbox_field___2'}, {'original_field_name': 'form_1_complete', 'choice_value': '', 'export_field_name': 'form_1_complete'}] \"\"\" # pylint: disable=line-too-long # pylint: enable=line-too-long ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"exportFieldNames\" , format = ret_format ) if field : payload [ \"field\" ] = field response , _ = self . _call_api ( payload , \"exp_field_names\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : df_kwargs = { \"index_col\" : \"original_field_name\" } return self . _read_csv ( StringIO ( response ), ** df_kwargs ) # pylint: enable=redefined-builtin def_field : str inherited property readonly The 'record_id' field equivalent for a project events : Optional [ List [ dict ]] inherited property readonly Project defined events !!! note Exists for longitudinal projects only field_names : List [ str ] inherited property readonly Project field names !!! note These are survey field names, not export field names is_longitudinal : bool inherited property readonly Whether or not this project is longitudinal metadata : List [ Dict [ str , str ]] inherited property readonly Project metadata in JSON format token : str inherited property readonly API token to your project url : str inherited property readonly API URL to your REDCap server export_field_names ( self , field = None , format = 'json' , df_kwargs = None ) Export the project's export field names Parameters: Name Type Description Default field Optional[str] Limit exported field name to this field (only single field supported). When not provided, all fields returned None format str 'json' , 'csv' , 'xml' , 'df' Return the metadata in native objects, csv or xml. 'df' will return a pandas.DataFrame 'json' df_kwargs Optional[Dict] Passed to pandas.read_csv to control construction of returned DataFrame. by default {'index_col': 'original_field_name'} None Returns: Type Description Union[str, List[Dict], \"pd.DataFrame\"] Metadata structure for the project. Examples: >>> proj . export_field_names () [{ 'original_field_name' : 'record_id' , 'choice_value' : '' , 'export_field_name' : 'record_id' }, { 'original_field_name' : 'field_1' , 'choice_value' : '' , 'export_field_name' : 'field_1' }, { 'original_field_name' : 'checkbox_field' , 'choice_value' : '1' , 'export_field_name' : 'checkbox_field___1' }, { 'original_field_name' : 'checkbox_field' , 'choice_value' : '2' , 'export_field_name' : 'checkbox_field___2' }, { 'original_field_name' : 'form_1_complete' , 'choice_value' : '' , 'export_field_name' : 'form_1_complete' }] Source code in redcap/methods/field_names.py def export_field_names ( self , field : Optional [ str ] = None , format : str = \"json\" , df_kwargs : Optional [ Dict ] = None , ): \"\"\" Export the project's export field names Args: field: Limit exported field name to this field (only single field supported). When not provided, all fields returned format: `'json'`, `'csv'`, `'xml'`, `'df'` Return the metadata in native objects, csv or xml. `'df'` will return a `pandas.DataFrame` df_kwargs: Passed to `pandas.read_csv` to control construction of returned DataFrame. by default `{'index_col': 'original_field_name'}` Returns: Union[str, List[Dict], \"pd.DataFrame\"]: Metadata structure for the project. Examples: >>> proj.export_field_names() [{'original_field_name': 'record_id', 'choice_value': '', 'export_field_name': 'record_id'}, {'original_field_name': 'field_1', 'choice_value': '', 'export_field_name': 'field_1'}, {'original_field_name': 'checkbox_field', 'choice_value': '1', 'export_field_name': 'checkbox_field___1'}, {'original_field_name': 'checkbox_field', 'choice_value': '2', 'export_field_name': 'checkbox_field___2'}, {'original_field_name': 'form_1_complete', 'choice_value': '', 'export_field_name': 'form_1_complete'}] \"\"\" # pylint: disable=line-too-long # pylint: enable=line-too-long ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"exportFieldNames\" , format = ret_format ) if field : payload [ \"field\" ] = field response , _ = self . _call_api ( payload , \"exp_field_names\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : df_kwargs = { \"index_col\" : \"original_field_name\" } return self . _read_csv ( StringIO ( response ), ** df_kwargs )","title":"Field Names"},{"location":"api_reference/field_names/#field-names","text":"REDCap API methods for Project field names","title":"Field Names"},{"location":"api_reference/field_names/#redcap.methods.field_names.FieldNames","text":"Responsible for all API methods under 'Field Names' in the API Playground Source code in redcap/methods/field_names.py class FieldNames ( Base ): \"\"\"Responsible for all API methods under 'Field Names' in the API Playground\"\"\" # pylint: disable=redefined-builtin @overload def export_field_names ( self , field : str , format : str = \"json\" , df_kwargs : Optional [ Dict ] = None ) -> str : ... @overload def export_field_names ( self , field : None = None , format : str = \"json\" , df_kwargs : Optional [ Dict ] = None ) -> Union [ List [ Dict ], \"pd.DataFrame\" ]: ... def export_field_names ( self , field : Optional [ str ] = None , format : str = \"json\" , df_kwargs : Optional [ Dict ] = None , ): \"\"\" Export the project's export field names Args: field: Limit exported field name to this field (only single field supported). When not provided, all fields returned format: `'json'`, `'csv'`, `'xml'`, `'df'` Return the metadata in native objects, csv or xml. `'df'` will return a `pandas.DataFrame` df_kwargs: Passed to `pandas.read_csv` to control construction of returned DataFrame. by default `{'index_col': 'original_field_name'}` Returns: Union[str, List[Dict], \"pd.DataFrame\"]: Metadata structure for the project. Examples: >>> proj.export_field_names() [{'original_field_name': 'record_id', 'choice_value': '', 'export_field_name': 'record_id'}, {'original_field_name': 'field_1', 'choice_value': '', 'export_field_name': 'field_1'}, {'original_field_name': 'checkbox_field', 'choice_value': '1', 'export_field_name': 'checkbox_field___1'}, {'original_field_name': 'checkbox_field', 'choice_value': '2', 'export_field_name': 'checkbox_field___2'}, {'original_field_name': 'form_1_complete', 'choice_value': '', 'export_field_name': 'form_1_complete'}] \"\"\" # pylint: disable=line-too-long # pylint: enable=line-too-long ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"exportFieldNames\" , format = ret_format ) if field : payload [ \"field\" ] = field response , _ = self . _call_api ( payload , \"exp_field_names\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : df_kwargs = { \"index_col\" : \"original_field_name\" } return self . _read_csv ( StringIO ( response ), ** df_kwargs ) # pylint: enable=redefined-builtin","title":"FieldNames"},{"location":"api_reference/field_names/#redcap.methods.field_names.FieldNames.def_field","text":"The 'record_id' field equivalent for a project","title":"def_field"},{"location":"api_reference/field_names/#redcap.methods.field_names.FieldNames.events","text":"Project defined events !!! note Exists for longitudinal projects only","title":"events"},{"location":"api_reference/field_names/#redcap.methods.field_names.FieldNames.field_names","text":"Project field names !!! note These are survey field names, not export field names","title":"field_names"},{"location":"api_reference/field_names/#redcap.methods.field_names.FieldNames.is_longitudinal","text":"Whether or not this project is longitudinal","title":"is_longitudinal"},{"location":"api_reference/field_names/#redcap.methods.field_names.FieldNames.metadata","text":"Project metadata in JSON format","title":"metadata"},{"location":"api_reference/field_names/#redcap.methods.field_names.FieldNames.token","text":"API token to your project","title":"token"},{"location":"api_reference/field_names/#redcap.methods.field_names.FieldNames.url","text":"API URL to your REDCap server","title":"url"},{"location":"api_reference/field_names/#redcap.methods.field_names.FieldNames.export_field_names","text":"Export the project's export field names Parameters: Name Type Description Default field Optional[str] Limit exported field name to this field (only single field supported). When not provided, all fields returned None format str 'json' , 'csv' , 'xml' , 'df' Return the metadata in native objects, csv or xml. 'df' will return a pandas.DataFrame 'json' df_kwargs Optional[Dict] Passed to pandas.read_csv to control construction of returned DataFrame. by default {'index_col': 'original_field_name'} None Returns: Type Description Union[str, List[Dict], \"pd.DataFrame\"] Metadata structure for the project. Examples: >>> proj . export_field_names () [{ 'original_field_name' : 'record_id' , 'choice_value' : '' , 'export_field_name' : 'record_id' }, { 'original_field_name' : 'field_1' , 'choice_value' : '' , 'export_field_name' : 'field_1' }, { 'original_field_name' : 'checkbox_field' , 'choice_value' : '1' , 'export_field_name' : 'checkbox_field___1' }, { 'original_field_name' : 'checkbox_field' , 'choice_value' : '2' , 'export_field_name' : 'checkbox_field___2' }, { 'original_field_name' : 'form_1_complete' , 'choice_value' : '' , 'export_field_name' : 'form_1_complete' }] Source code in redcap/methods/field_names.py def export_field_names ( self , field : Optional [ str ] = None , format : str = \"json\" , df_kwargs : Optional [ Dict ] = None , ): \"\"\" Export the project's export field names Args: field: Limit exported field name to this field (only single field supported). When not provided, all fields returned format: `'json'`, `'csv'`, `'xml'`, `'df'` Return the metadata in native objects, csv or xml. `'df'` will return a `pandas.DataFrame` df_kwargs: Passed to `pandas.read_csv` to control construction of returned DataFrame. by default `{'index_col': 'original_field_name'}` Returns: Union[str, List[Dict], \"pd.DataFrame\"]: Metadata structure for the project. Examples: >>> proj.export_field_names() [{'original_field_name': 'record_id', 'choice_value': '', 'export_field_name': 'record_id'}, {'original_field_name': 'field_1', 'choice_value': '', 'export_field_name': 'field_1'}, {'original_field_name': 'checkbox_field', 'choice_value': '1', 'export_field_name': 'checkbox_field___1'}, {'original_field_name': 'checkbox_field', 'choice_value': '2', 'export_field_name': 'checkbox_field___2'}, {'original_field_name': 'form_1_complete', 'choice_value': '', 'export_field_name': 'form_1_complete'}] \"\"\" # pylint: disable=line-too-long # pylint: enable=line-too-long ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"exportFieldNames\" , format = ret_format ) if field : payload [ \"field\" ] = field response , _ = self . _call_api ( payload , \"exp_field_names\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : df_kwargs = { \"index_col\" : \"original_field_name\" } return self . _read_csv ( StringIO ( response ), ** df_kwargs )","title":"export_field_names()"},{"location":"api_reference/files/","text":"Files REDCap API methods for Project files Files ( Base ) Responsible for all API methods under 'Files' in the API Playground Source code in redcap/methods/files.py class Files ( Base ): \"\"\"Responsible for all API methods under 'Files' in the API Playground\"\"\" def _check_file_field ( self , field : str ) -> bool : \"\"\"Check that field exists and is a file field\"\"\" is_field = field in self . field_names is_file = self . _filter_metadata ( key = \"field_type\" , field_name = field ) == \"file\" if not ( is_field and is_file ): msg = f \"' { field } ' is not a field or not a 'file' field\" raise ValueError ( msg ) return True def export_file ( self , record : str , field : str , event : Optional [ str ] = None , return_format : str = \"json\" , repeat_instance : Optional [ int ] = None , ) -> Tuple [ bytes , Dict ]: \"\"\" Export the contents of a file stored for a particular record Note: Unlike other export methods, this only works on a single record. Args: record: Record ID field: Field name containing the file to be exported. event: For longitudinal projects, the unique event name return_format: `'json'`, `'csv'`, `'xml'` Format of error message repeat_instance: (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). Returns: Content of the file and content-type dictionary Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> proj.export_file(record=\"1\", field=\"upload_field\", event=\"event_1_arm_1\") (b'test upload\\\\n', {'name': 'test_upload.txt', 'charset': 'UTF-8'}) \"\"\" assert self . _check_file_field ( field ) # load up payload payload = self . _basepl ( content = \"file\" , format = return_format ) # there's no format field in this call del payload [ \"format\" ] payload [ \"returnFormat\" ] = return_format payload [ \"action\" ] = \"export\" payload [ \"field\" ] = field payload [ \"record\" ] = record if event : payload [ \"event\" ] = event if repeat_instance : payload [ \"repeat_instance\" ] = str ( repeat_instance ) content , headers = self . _call_api ( payload , \"exp_file\" ) # REDCap adds some useful things in content-type content_map = {} if \"content-type\" in headers : splat = [ key_values . strip () for key_values in headers [ \"content-type\" ] . split ( \";\" ) ] key_values = [ ( key_values . split ( \"=\" )[ 0 ], key_values . split ( \"=\" )[ 1 ] . replace ( '\"' , \"\" )) for key_values in splat if \"=\" in key_values ] content_map = dict ( key_values ) return content , content_map def import_file ( self , record : str , field : str , file_name : str , file_object : \"TextIOWrapper\" , event : Optional [ str ] = None , repeat_instance : Optional [ Union [ int , str ]] = None , return_format : str = \"json\" , ) -> Union [ Dict , Literal [ \"\" ]]: \"\"\" Import the contents of a file represented by file_object to a particular records field Args: record: Record ID field: Field name where the file will go file_name: File name visible in REDCap UI file_object: File object as returned by `open` event: For longitudinal projects, the unique event name repeat_instance: (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). return_format: `'json'`, `'csv'`, `'xml'` Format of error message Returns: Response from server as specified by `return_format` Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> import tempfile >>> tmp_file = tempfile.TemporaryFile() >>> proj.import_file( ... record=\"2\", ... field=\"upload_field\", ... file_name=\"myupload.txt\", ... file_object=tmp_file, ... event=\"event_1_arm_1\", ... ) {} \"\"\" self . _check_file_field ( field ) # load up payload payload = self . _basepl ( content = \"file\" , format = return_format ) # no format in this call del payload [ \"format\" ] payload [ \"returnFormat\" ] = return_format payload [ \"action\" ] = \"import\" payload [ \"field\" ] = field payload [ \"record\" ] = record if event : payload [ \"event\" ] = event if repeat_instance : payload [ \"repeat_instance\" ] = repeat_instance file_kwargs = { \"files\" : { \"file\" : ( file_name , file_object )}} return self . _call_api ( payload , \"imp_file\" , ** file_kwargs )[ 0 ] def delete_file ( self , record : str , field : str , event : Optional [ str ] = None , return_format : str = \"json\" , ) -> Union [ Dict , Literal [ \"\" ]]: \"\"\" Delete a file from REDCap Note: There is no undo button to this. Args: record: Record ID field: Field name event: For longitudinal projects, the unique event name return_format: `'json'`, `'csv'`, `'xml'` Return format for error message Returns: Response from REDCap after deleting file Examples: Import a tempfile and then delete it >>> import tempfile >>> tmp_file = tempfile.TemporaryFile() >>> proj.import_file( ... record=\"2\", ... field=\"upload_field\", ... file_name=\"myupload.txt\", ... file_object=tmp_file, ... event=\"event_1_arm_1\", ... ) {} >>> proj.delete_file(record=\"2\", field=\"upload_field\", event=\"event_1_arm_1\") {} \"\"\" self . _check_file_field ( field ) # Load up payload payload = self . _basepl ( content = \"file\" , format = return_format ) del payload [ \"format\" ] payload [ \"returnFormat\" ] = return_format payload [ \"action\" ] = \"delete\" payload [ \"record\" ] = record payload [ \"field\" ] = field if event : payload [ \"event\" ] = event return self . _call_api ( payload , \"del_file\" )[ 0 ] def_field : str inherited property readonly The 'record_id' field equivalent for a project events : Optional [ List [ dict ]] inherited property readonly Project defined events !!! note Exists for longitudinal projects only field_names : List [ str ] inherited property readonly Project field names !!! note These are survey field names, not export field names is_longitudinal : bool inherited property readonly Whether or not this project is longitudinal metadata : List [ Dict [ str , str ]] inherited property readonly Project metadata in JSON format token : str inherited property readonly API token to your project url : str inherited property readonly API URL to your REDCap server delete_file ( self , record , field , event = None , return_format = 'json' ) Delete a file from REDCap !!! note There is no undo button to this. Parameters: Name Type Description Default record str Record ID required field str Field name required event Optional[str] For longitudinal projects, the unique event name None return_format str 'json' , 'csv' , 'xml' Return format for error message 'json' Returns: Type Description Union[Dict, Literal['']] Response from REDCap after deleting file Examples: Import a tempfile and then delete it >>> import tempfile >>> tmp_file = tempfile . TemporaryFile () >>> proj . import_file ( ... record = \"2\" , ... field = \"upload_field\" , ... file_name = \"myupload.txt\" , ... file_object = tmp_file , ... event = \"event_1_arm_1\" , ... ) {} >>> proj . delete_file ( record = \"2\" , field = \"upload_field\" , event = \"event_1_arm_1\" ) {} Source code in redcap/methods/files.py def delete_file ( self , record : str , field : str , event : Optional [ str ] = None , return_format : str = \"json\" , ) -> Union [ Dict , Literal [ \"\" ]]: \"\"\" Delete a file from REDCap Note: There is no undo button to this. Args: record: Record ID field: Field name event: For longitudinal projects, the unique event name return_format: `'json'`, `'csv'`, `'xml'` Return format for error message Returns: Response from REDCap after deleting file Examples: Import a tempfile and then delete it >>> import tempfile >>> tmp_file = tempfile.TemporaryFile() >>> proj.import_file( ... record=\"2\", ... field=\"upload_field\", ... file_name=\"myupload.txt\", ... file_object=tmp_file, ... event=\"event_1_arm_1\", ... ) {} >>> proj.delete_file(record=\"2\", field=\"upload_field\", event=\"event_1_arm_1\") {} \"\"\" self . _check_file_field ( field ) # Load up payload payload = self . _basepl ( content = \"file\" , format = return_format ) del payload [ \"format\" ] payload [ \"returnFormat\" ] = return_format payload [ \"action\" ] = \"delete\" payload [ \"record\" ] = record payload [ \"field\" ] = field if event : payload [ \"event\" ] = event return self . _call_api ( payload , \"del_file\" )[ 0 ] export_file ( self , record , field , event = None , return_format = 'json' , repeat_instance = None ) Export the contents of a file stored for a particular record !!! note Unlike other export methods, this only works on a single record. Parameters: Name Type Description Default record str Record ID required field str Field name containing the file to be exported. required event Optional[str] For longitudinal projects, the unique event name None return_format str 'json' , 'csv' , 'xml' Format of error message 'json' repeat_instance Optional[int] (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). None Returns: Type Description Tuple[bytes, Dict] Content of the file and content-type dictionary Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> proj . export_file ( record = \"1\" , field = \"upload_field\" , event = \"event_1_arm_1\" ) ( b 'test upload \\n ' , { 'name' : 'test_upload.txt' , 'charset' : 'UTF-8' }) Source code in redcap/methods/files.py def export_file ( self , record : str , field : str , event : Optional [ str ] = None , return_format : str = \"json\" , repeat_instance : Optional [ int ] = None , ) -> Tuple [ bytes , Dict ]: \"\"\" Export the contents of a file stored for a particular record Note: Unlike other export methods, this only works on a single record. Args: record: Record ID field: Field name containing the file to be exported. event: For longitudinal projects, the unique event name return_format: `'json'`, `'csv'`, `'xml'` Format of error message repeat_instance: (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). Returns: Content of the file and content-type dictionary Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> proj.export_file(record=\"1\", field=\"upload_field\", event=\"event_1_arm_1\") (b'test upload\\\\n', {'name': 'test_upload.txt', 'charset': 'UTF-8'}) \"\"\" assert self . _check_file_field ( field ) # load up payload payload = self . _basepl ( content = \"file\" , format = return_format ) # there's no format field in this call del payload [ \"format\" ] payload [ \"returnFormat\" ] = return_format payload [ \"action\" ] = \"export\" payload [ \"field\" ] = field payload [ \"record\" ] = record if event : payload [ \"event\" ] = event if repeat_instance : payload [ \"repeat_instance\" ] = str ( repeat_instance ) content , headers = self . _call_api ( payload , \"exp_file\" ) # REDCap adds some useful things in content-type content_map = {} if \"content-type\" in headers : splat = [ key_values . strip () for key_values in headers [ \"content-type\" ] . split ( \";\" ) ] key_values = [ ( key_values . split ( \"=\" )[ 0 ], key_values . split ( \"=\" )[ 1 ] . replace ( '\"' , \"\" )) for key_values in splat if \"=\" in key_values ] content_map = dict ( key_values ) return content , content_map import_file ( self , record , field , file_name , file_object , event = None , repeat_instance = None , return_format = 'json' ) Import the contents of a file represented by file_object to a particular records field Parameters: Name Type Description Default record str Record ID required field str Field name where the file will go required file_name str File name visible in REDCap UI required file_object TextIOWrapper File object as returned by open required event Optional[str] For longitudinal projects, the unique event name None repeat_instance Union[int, str] (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). None return_format str 'json' , 'csv' , 'xml' Format of error message 'json' Returns: Type Description Union[Dict, Literal['']] Response from server as specified by return_format Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> import tempfile >>> tmp_file = tempfile . TemporaryFile () >>> proj . import_file ( ... record = \"2\" , ... field = \"upload_field\" , ... file_name = \"myupload.txt\" , ... file_object = tmp_file , ... event = \"event_1_arm_1\" , ... ) {} Source code in redcap/methods/files.py def import_file ( self , record : str , field : str , file_name : str , file_object : \"TextIOWrapper\" , event : Optional [ str ] = None , repeat_instance : Optional [ Union [ int , str ]] = None , return_format : str = \"json\" , ) -> Union [ Dict , Literal [ \"\" ]]: \"\"\" Import the contents of a file represented by file_object to a particular records field Args: record: Record ID field: Field name where the file will go file_name: File name visible in REDCap UI file_object: File object as returned by `open` event: For longitudinal projects, the unique event name repeat_instance: (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). return_format: `'json'`, `'csv'`, `'xml'` Format of error message Returns: Response from server as specified by `return_format` Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> import tempfile >>> tmp_file = tempfile.TemporaryFile() >>> proj.import_file( ... record=\"2\", ... field=\"upload_field\", ... file_name=\"myupload.txt\", ... file_object=tmp_file, ... event=\"event_1_arm_1\", ... ) {} \"\"\" self . _check_file_field ( field ) # load up payload payload = self . _basepl ( content = \"file\" , format = return_format ) # no format in this call del payload [ \"format\" ] payload [ \"returnFormat\" ] = return_format payload [ \"action\" ] = \"import\" payload [ \"field\" ] = field payload [ \"record\" ] = record if event : payload [ \"event\" ] = event if repeat_instance : payload [ \"repeat_instance\" ] = repeat_instance file_kwargs = { \"files\" : { \"file\" : ( file_name , file_object )}} return self . _call_api ( payload , \"imp_file\" , ** file_kwargs )[ 0 ]","title":"Files"},{"location":"api_reference/files/#files","text":"REDCap API methods for Project files","title":"Files"},{"location":"api_reference/files/#redcap.methods.files.Files","text":"Responsible for all API methods under 'Files' in the API Playground Source code in redcap/methods/files.py class Files ( Base ): \"\"\"Responsible for all API methods under 'Files' in the API Playground\"\"\" def _check_file_field ( self , field : str ) -> bool : \"\"\"Check that field exists and is a file field\"\"\" is_field = field in self . field_names is_file = self . _filter_metadata ( key = \"field_type\" , field_name = field ) == \"file\" if not ( is_field and is_file ): msg = f \"' { field } ' is not a field or not a 'file' field\" raise ValueError ( msg ) return True def export_file ( self , record : str , field : str , event : Optional [ str ] = None , return_format : str = \"json\" , repeat_instance : Optional [ int ] = None , ) -> Tuple [ bytes , Dict ]: \"\"\" Export the contents of a file stored for a particular record Note: Unlike other export methods, this only works on a single record. Args: record: Record ID field: Field name containing the file to be exported. event: For longitudinal projects, the unique event name return_format: `'json'`, `'csv'`, `'xml'` Format of error message repeat_instance: (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). Returns: Content of the file and content-type dictionary Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> proj.export_file(record=\"1\", field=\"upload_field\", event=\"event_1_arm_1\") (b'test upload\\\\n', {'name': 'test_upload.txt', 'charset': 'UTF-8'}) \"\"\" assert self . _check_file_field ( field ) # load up payload payload = self . _basepl ( content = \"file\" , format = return_format ) # there's no format field in this call del payload [ \"format\" ] payload [ \"returnFormat\" ] = return_format payload [ \"action\" ] = \"export\" payload [ \"field\" ] = field payload [ \"record\" ] = record if event : payload [ \"event\" ] = event if repeat_instance : payload [ \"repeat_instance\" ] = str ( repeat_instance ) content , headers = self . _call_api ( payload , \"exp_file\" ) # REDCap adds some useful things in content-type content_map = {} if \"content-type\" in headers : splat = [ key_values . strip () for key_values in headers [ \"content-type\" ] . split ( \";\" ) ] key_values = [ ( key_values . split ( \"=\" )[ 0 ], key_values . split ( \"=\" )[ 1 ] . replace ( '\"' , \"\" )) for key_values in splat if \"=\" in key_values ] content_map = dict ( key_values ) return content , content_map def import_file ( self , record : str , field : str , file_name : str , file_object : \"TextIOWrapper\" , event : Optional [ str ] = None , repeat_instance : Optional [ Union [ int , str ]] = None , return_format : str = \"json\" , ) -> Union [ Dict , Literal [ \"\" ]]: \"\"\" Import the contents of a file represented by file_object to a particular records field Args: record: Record ID field: Field name where the file will go file_name: File name visible in REDCap UI file_object: File object as returned by `open` event: For longitudinal projects, the unique event name repeat_instance: (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). return_format: `'json'`, `'csv'`, `'xml'` Format of error message Returns: Response from server as specified by `return_format` Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> import tempfile >>> tmp_file = tempfile.TemporaryFile() >>> proj.import_file( ... record=\"2\", ... field=\"upload_field\", ... file_name=\"myupload.txt\", ... file_object=tmp_file, ... event=\"event_1_arm_1\", ... ) {} \"\"\" self . _check_file_field ( field ) # load up payload payload = self . _basepl ( content = \"file\" , format = return_format ) # no format in this call del payload [ \"format\" ] payload [ \"returnFormat\" ] = return_format payload [ \"action\" ] = \"import\" payload [ \"field\" ] = field payload [ \"record\" ] = record if event : payload [ \"event\" ] = event if repeat_instance : payload [ \"repeat_instance\" ] = repeat_instance file_kwargs = { \"files\" : { \"file\" : ( file_name , file_object )}} return self . _call_api ( payload , \"imp_file\" , ** file_kwargs )[ 0 ] def delete_file ( self , record : str , field : str , event : Optional [ str ] = None , return_format : str = \"json\" , ) -> Union [ Dict , Literal [ \"\" ]]: \"\"\" Delete a file from REDCap Note: There is no undo button to this. Args: record: Record ID field: Field name event: For longitudinal projects, the unique event name return_format: `'json'`, `'csv'`, `'xml'` Return format for error message Returns: Response from REDCap after deleting file Examples: Import a tempfile and then delete it >>> import tempfile >>> tmp_file = tempfile.TemporaryFile() >>> proj.import_file( ... record=\"2\", ... field=\"upload_field\", ... file_name=\"myupload.txt\", ... file_object=tmp_file, ... event=\"event_1_arm_1\", ... ) {} >>> proj.delete_file(record=\"2\", field=\"upload_field\", event=\"event_1_arm_1\") {} \"\"\" self . _check_file_field ( field ) # Load up payload payload = self . _basepl ( content = \"file\" , format = return_format ) del payload [ \"format\" ] payload [ \"returnFormat\" ] = return_format payload [ \"action\" ] = \"delete\" payload [ \"record\" ] = record payload [ \"field\" ] = field if event : payload [ \"event\" ] = event return self . _call_api ( payload , \"del_file\" )[ 0 ]","title":"Files"},{"location":"api_reference/files/#redcap.methods.files.Files.def_field","text":"The 'record_id' field equivalent for a project","title":"def_field"},{"location":"api_reference/files/#redcap.methods.files.Files.events","text":"Project defined events !!! note Exists for longitudinal projects only","title":"events"},{"location":"api_reference/files/#redcap.methods.files.Files.field_names","text":"Project field names !!! note These are survey field names, not export field names","title":"field_names"},{"location":"api_reference/files/#redcap.methods.files.Files.is_longitudinal","text":"Whether or not this project is longitudinal","title":"is_longitudinal"},{"location":"api_reference/files/#redcap.methods.files.Files.metadata","text":"Project metadata in JSON format","title":"metadata"},{"location":"api_reference/files/#redcap.methods.files.Files.token","text":"API token to your project","title":"token"},{"location":"api_reference/files/#redcap.methods.files.Files.url","text":"API URL to your REDCap server","title":"url"},{"location":"api_reference/files/#redcap.methods.files.Files.delete_file","text":"Delete a file from REDCap !!! note There is no undo button to this. Parameters: Name Type Description Default record str Record ID required field str Field name required event Optional[str] For longitudinal projects, the unique event name None return_format str 'json' , 'csv' , 'xml' Return format for error message 'json' Returns: Type Description Union[Dict, Literal['']] Response from REDCap after deleting file Examples: Import a tempfile and then delete it >>> import tempfile >>> tmp_file = tempfile . TemporaryFile () >>> proj . import_file ( ... record = \"2\" , ... field = \"upload_field\" , ... file_name = \"myupload.txt\" , ... file_object = tmp_file , ... event = \"event_1_arm_1\" , ... ) {} >>> proj . delete_file ( record = \"2\" , field = \"upload_field\" , event = \"event_1_arm_1\" ) {} Source code in redcap/methods/files.py def delete_file ( self , record : str , field : str , event : Optional [ str ] = None , return_format : str = \"json\" , ) -> Union [ Dict , Literal [ \"\" ]]: \"\"\" Delete a file from REDCap Note: There is no undo button to this. Args: record: Record ID field: Field name event: For longitudinal projects, the unique event name return_format: `'json'`, `'csv'`, `'xml'` Return format for error message Returns: Response from REDCap after deleting file Examples: Import a tempfile and then delete it >>> import tempfile >>> tmp_file = tempfile.TemporaryFile() >>> proj.import_file( ... record=\"2\", ... field=\"upload_field\", ... file_name=\"myupload.txt\", ... file_object=tmp_file, ... event=\"event_1_arm_1\", ... ) {} >>> proj.delete_file(record=\"2\", field=\"upload_field\", event=\"event_1_arm_1\") {} \"\"\" self . _check_file_field ( field ) # Load up payload payload = self . _basepl ( content = \"file\" , format = return_format ) del payload [ \"format\" ] payload [ \"returnFormat\" ] = return_format payload [ \"action\" ] = \"delete\" payload [ \"record\" ] = record payload [ \"field\" ] = field if event : payload [ \"event\" ] = event return self . _call_api ( payload , \"del_file\" )[ 0 ]","title":"delete_file()"},{"location":"api_reference/files/#redcap.methods.files.Files.export_file","text":"Export the contents of a file stored for a particular record !!! note Unlike other export methods, this only works on a single record. Parameters: Name Type Description Default record str Record ID required field str Field name containing the file to be exported. required event Optional[str] For longitudinal projects, the unique event name None return_format str 'json' , 'csv' , 'xml' Format of error message 'json' repeat_instance Optional[int] (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). None Returns: Type Description Tuple[bytes, Dict] Content of the file and content-type dictionary Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> proj . export_file ( record = \"1\" , field = \"upload_field\" , event = \"event_1_arm_1\" ) ( b 'test upload \\n ' , { 'name' : 'test_upload.txt' , 'charset' : 'UTF-8' }) Source code in redcap/methods/files.py def export_file ( self , record : str , field : str , event : Optional [ str ] = None , return_format : str = \"json\" , repeat_instance : Optional [ int ] = None , ) -> Tuple [ bytes , Dict ]: \"\"\" Export the contents of a file stored for a particular record Note: Unlike other export methods, this only works on a single record. Args: record: Record ID field: Field name containing the file to be exported. event: For longitudinal projects, the unique event name return_format: `'json'`, `'csv'`, `'xml'` Format of error message repeat_instance: (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). Returns: Content of the file and content-type dictionary Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> proj.export_file(record=\"1\", field=\"upload_field\", event=\"event_1_arm_1\") (b'test upload\\\\n', {'name': 'test_upload.txt', 'charset': 'UTF-8'}) \"\"\" assert self . _check_file_field ( field ) # load up payload payload = self . _basepl ( content = \"file\" , format = return_format ) # there's no format field in this call del payload [ \"format\" ] payload [ \"returnFormat\" ] = return_format payload [ \"action\" ] = \"export\" payload [ \"field\" ] = field payload [ \"record\" ] = record if event : payload [ \"event\" ] = event if repeat_instance : payload [ \"repeat_instance\" ] = str ( repeat_instance ) content , headers = self . _call_api ( payload , \"exp_file\" ) # REDCap adds some useful things in content-type content_map = {} if \"content-type\" in headers : splat = [ key_values . strip () for key_values in headers [ \"content-type\" ] . split ( \";\" ) ] key_values = [ ( key_values . split ( \"=\" )[ 0 ], key_values . split ( \"=\" )[ 1 ] . replace ( '\"' , \"\" )) for key_values in splat if \"=\" in key_values ] content_map = dict ( key_values ) return content , content_map","title":"export_file()"},{"location":"api_reference/files/#redcap.methods.files.Files.import_file","text":"Import the contents of a file represented by file_object to a particular records field Parameters: Name Type Description Default record str Record ID required field str Field name where the file will go required file_name str File name visible in REDCap UI required file_object TextIOWrapper File object as returned by open required event Optional[str] For longitudinal projects, the unique event name None repeat_instance Union[int, str] (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). None return_format str 'json' , 'csv' , 'xml' Format of error message 'json' Returns: Type Description Union[Dict, Literal['']] Response from server as specified by return_format Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> import tempfile >>> tmp_file = tempfile . TemporaryFile () >>> proj . import_file ( ... record = \"2\" , ... field = \"upload_field\" , ... file_name = \"myupload.txt\" , ... file_object = tmp_file , ... event = \"event_1_arm_1\" , ... ) {} Source code in redcap/methods/files.py def import_file ( self , record : str , field : str , file_name : str , file_object : \"TextIOWrapper\" , event : Optional [ str ] = None , repeat_instance : Optional [ Union [ int , str ]] = None , return_format : str = \"json\" , ) -> Union [ Dict , Literal [ \"\" ]]: \"\"\" Import the contents of a file represented by file_object to a particular records field Args: record: Record ID field: Field name where the file will go file_name: File name visible in REDCap UI file_object: File object as returned by `open` event: For longitudinal projects, the unique event name repeat_instance: (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). return_format: `'json'`, `'csv'`, `'xml'` Format of error message Returns: Response from server as specified by `return_format` Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> import tempfile >>> tmp_file = tempfile.TemporaryFile() >>> proj.import_file( ... record=\"2\", ... field=\"upload_field\", ... file_name=\"myupload.txt\", ... file_object=tmp_file, ... event=\"event_1_arm_1\", ... ) {} \"\"\" self . _check_file_field ( field ) # load up payload payload = self . _basepl ( content = \"file\" , format = return_format ) # no format in this call del payload [ \"format\" ] payload [ \"returnFormat\" ] = return_format payload [ \"action\" ] = \"import\" payload [ \"field\" ] = field payload [ \"record\" ] = record if event : payload [ \"event\" ] = event if repeat_instance : payload [ \"repeat_instance\" ] = repeat_instance file_kwargs = { \"files\" : { \"file\" : ( file_name , file_object )}} return self . _call_api ( payload , \"imp_file\" , ** file_kwargs )[ 0 ]","title":"import_file()"},{"location":"api_reference/instruments/","text":"Instruments REDCap API methods for Project instruments Instruments ( Base ) Responsible for all API methods under 'Instruments' in the API Playground Source code in redcap/methods/instruments.py class Instruments ( Base ): \"\"\"Responsible for all API methods under 'Instruments' in the API Playground\"\"\" # pylint: disable=redefined-builtin @overload def export_instrument_event_mappings ( self , format : Literal [ \"json\" ], arms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ) -> List [ Dict ]: ... @overload def export_instrument_event_mappings ( self , format : Literal [ \"csv\" , \"xml\" ], arms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ) -> str : ... @overload def export_instrument_event_mappings ( self , format : Literal [ \"df\" ], arms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ) -> \"pd.DataFrame\" : ... def export_instrument_event_mappings ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , arms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ): \"\"\" Export the project's instrument to event mapping Args: format: Return the form event mappings in native objects, csv or xml, `'df''` will return a `pandas.DataFrame` arms: Limit exported form event mappings to these arm numbers df_kwargs: Passed to pandas.read_csv to control construction of returned DataFrame Returns: Union[str, List[Dict], pd.DataFrame]: Instrument-event mapping for the project Examples: >>> proj.export_instrument_event_mappings() [{'arm_num': 1, 'unique_event_name': 'event_1_arm_1', 'form': 'form_1'}] \"\"\" ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"formEventMapping\" , format = ret_format ) if arms : for i , value in enumerate ( arms ): payload [ f \"arms[ { i } ]\" ] = value response , _ = self . _call_api ( payload , \"exp_fem\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : df_kwargs = {} return self . _read_csv ( StringIO ( response ), ** df_kwargs ) # pylint: enable=redefined-builtin def_field : str inherited property readonly The 'record_id' field equivalent for a project events : Optional [ List [ dict ]] inherited property readonly Project defined events !!! note Exists for longitudinal projects only field_names : List [ str ] inherited property readonly Project field names !!! note These are survey field names, not export field names is_longitudinal : bool inherited property readonly Whether or not this project is longitudinal metadata : List [ Dict [ str , str ]] inherited property readonly Project metadata in JSON format token : str inherited property readonly API token to your project url : str inherited property readonly API URL to your REDCap server export_instrument_event_mappings ( self , format = 'json' , arms = None , df_kwargs = None ) Export the project's instrument to event mapping Parameters: Name Type Description Default format Literal['json', 'csv', 'xml', 'df'] Return the form event mappings in native objects, csv or xml, 'df'' will return a pandas.DataFrame 'json' arms Optional[List[str]] Limit exported form event mappings to these arm numbers None df_kwargs Optional[Dict] Passed to pandas.read_csv to control construction of returned DataFrame None Returns: Type Description Union[str, List[Dict], pd.DataFrame] Instrument-event mapping for the project Examples: >>> proj . export_instrument_event_mappings () [{ 'arm_num' : 1 , 'unique_event_name' : 'event_1_arm_1' , 'form' : 'form_1' }] Source code in redcap/methods/instruments.py def export_instrument_event_mappings ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , arms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ): \"\"\" Export the project's instrument to event mapping Args: format: Return the form event mappings in native objects, csv or xml, `'df''` will return a `pandas.DataFrame` arms: Limit exported form event mappings to these arm numbers df_kwargs: Passed to pandas.read_csv to control construction of returned DataFrame Returns: Union[str, List[Dict], pd.DataFrame]: Instrument-event mapping for the project Examples: >>> proj.export_instrument_event_mappings() [{'arm_num': 1, 'unique_event_name': 'event_1_arm_1', 'form': 'form_1'}] \"\"\" ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"formEventMapping\" , format = ret_format ) if arms : for i , value in enumerate ( arms ): payload [ f \"arms[ { i } ]\" ] = value response , _ = self . _call_api ( payload , \"exp_fem\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : df_kwargs = {} return self . _read_csv ( StringIO ( response ), ** df_kwargs )","title":"Instruments"},{"location":"api_reference/instruments/#instruments","text":"REDCap API methods for Project instruments","title":"Instruments"},{"location":"api_reference/instruments/#redcap.methods.instruments.Instruments","text":"Responsible for all API methods under 'Instruments' in the API Playground Source code in redcap/methods/instruments.py class Instruments ( Base ): \"\"\"Responsible for all API methods under 'Instruments' in the API Playground\"\"\" # pylint: disable=redefined-builtin @overload def export_instrument_event_mappings ( self , format : Literal [ \"json\" ], arms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ) -> List [ Dict ]: ... @overload def export_instrument_event_mappings ( self , format : Literal [ \"csv\" , \"xml\" ], arms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ) -> str : ... @overload def export_instrument_event_mappings ( self , format : Literal [ \"df\" ], arms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ) -> \"pd.DataFrame\" : ... def export_instrument_event_mappings ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , arms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ): \"\"\" Export the project's instrument to event mapping Args: format: Return the form event mappings in native objects, csv or xml, `'df''` will return a `pandas.DataFrame` arms: Limit exported form event mappings to these arm numbers df_kwargs: Passed to pandas.read_csv to control construction of returned DataFrame Returns: Union[str, List[Dict], pd.DataFrame]: Instrument-event mapping for the project Examples: >>> proj.export_instrument_event_mappings() [{'arm_num': 1, 'unique_event_name': 'event_1_arm_1', 'form': 'form_1'}] \"\"\" ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"formEventMapping\" , format = ret_format ) if arms : for i , value in enumerate ( arms ): payload [ f \"arms[ { i } ]\" ] = value response , _ = self . _call_api ( payload , \"exp_fem\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : df_kwargs = {} return self . _read_csv ( StringIO ( response ), ** df_kwargs ) # pylint: enable=redefined-builtin","title":"Instruments"},{"location":"api_reference/instruments/#redcap.methods.instruments.Instruments.def_field","text":"The 'record_id' field equivalent for a project","title":"def_field"},{"location":"api_reference/instruments/#redcap.methods.instruments.Instruments.events","text":"Project defined events !!! note Exists for longitudinal projects only","title":"events"},{"location":"api_reference/instruments/#redcap.methods.instruments.Instruments.field_names","text":"Project field names !!! note These are survey field names, not export field names","title":"field_names"},{"location":"api_reference/instruments/#redcap.methods.instruments.Instruments.is_longitudinal","text":"Whether or not this project is longitudinal","title":"is_longitudinal"},{"location":"api_reference/instruments/#redcap.methods.instruments.Instruments.metadata","text":"Project metadata in JSON format","title":"metadata"},{"location":"api_reference/instruments/#redcap.methods.instruments.Instruments.token","text":"API token to your project","title":"token"},{"location":"api_reference/instruments/#redcap.methods.instruments.Instruments.url","text":"API URL to your REDCap server","title":"url"},{"location":"api_reference/instruments/#redcap.methods.instruments.Instruments.export_instrument_event_mappings","text":"Export the project's instrument to event mapping Parameters: Name Type Description Default format Literal['json', 'csv', 'xml', 'df'] Return the form event mappings in native objects, csv or xml, 'df'' will return a pandas.DataFrame 'json' arms Optional[List[str]] Limit exported form event mappings to these arm numbers None df_kwargs Optional[Dict] Passed to pandas.read_csv to control construction of returned DataFrame None Returns: Type Description Union[str, List[Dict], pd.DataFrame] Instrument-event mapping for the project Examples: >>> proj . export_instrument_event_mappings () [{ 'arm_num' : 1 , 'unique_event_name' : 'event_1_arm_1' , 'form' : 'form_1' }] Source code in redcap/methods/instruments.py def export_instrument_event_mappings ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , arms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ): \"\"\" Export the project's instrument to event mapping Args: format: Return the form event mappings in native objects, csv or xml, `'df''` will return a `pandas.DataFrame` arms: Limit exported form event mappings to these arm numbers df_kwargs: Passed to pandas.read_csv to control construction of returned DataFrame Returns: Union[str, List[Dict], pd.DataFrame]: Instrument-event mapping for the project Examples: >>> proj.export_instrument_event_mappings() [{'arm_num': 1, 'unique_event_name': 'event_1_arm_1', 'form': 'form_1'}] \"\"\" ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"formEventMapping\" , format = ret_format ) if arms : for i , value in enumerate ( arms ): payload [ f \"arms[ { i } ]\" ] = value response , _ = self . _call_api ( payload , \"exp_fem\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : df_kwargs = {} return self . _read_csv ( StringIO ( response ), ** df_kwargs )","title":"export_instrument_event_mappings()"},{"location":"api_reference/metadata/","text":"Metadata REDCap API methods for Project metadata Metadata ( Base ) Responsible for all API methods under 'Metadata' in the API Playground Source code in redcap/methods/metadata.py class Metadata ( Base ): \"\"\"Responsible for all API methods under 'Metadata' in the API Playground\"\"\" # pylint: disable=redefined-builtin @overload def export_metadata ( self , format : Literal [ \"json\" ], fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ) -> List [ Dict ]: ... @overload def export_metadata ( self , format : Literal [ \"csv\" , \"xml\" ], fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ) -> str : ... @overload def export_metadata ( self , format : Literal [ \"df\" ], fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ) -> \"pd.DataFrame\" : ... def export_metadata ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ) -> Union [ str , List [ Dict ], \"pd.DataFrame\" ]: \"\"\" Export the project's metadata Args: format: Return the metadata in native objects, csv or xml. `'df'` will return a `pandas.DataFrame` fields: Limit exported metadata to these fields forms: Limit exported metadata to these forms df_kwargs: Passed to `pandas.read_csv` to control construction of returned DataFrame. By default `{'index_col': 'field_name'}` Returns: Union[str, List[Dict], pd.DataFrame]: Metadata structure for the project. Examples: >>> proj.export_metadata(format=\"df\") form_name section_header ... matrix_ranking field_annotation field_name ... record_id form_1 NaN ... NaN NaN field_1 form_1 NaN ... NaN NaN checkbox_field form_1 NaN ... NaN NaN upload_field form_1 NaN ... NaN NaN ... \"\"\" ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"metadata\" , format = ret_format ) to_add = [ fields , forms ] str_add = [ \"fields\" , \"forms\" ] for key , data in zip ( str_add , to_add ): if data : for i , value in enumerate ( data ): payload [ f \" { key } [ { i } ]\" ] = value response , _ = self . _call_api ( payload , \"metadata\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : df_kwargs = { \"index_col\" : \"field_name\" } return self . _read_csv ( StringIO ( response ), ** df_kwargs ) @overload def import_metadata ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"json\" ], format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , ) -> int : ... @overload def import_metadata ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"csv\" , \"xml\" ], format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , ) -> str : ... def import_metadata ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , ): \"\"\" Import metadata (Data Dictionary) into the REDCap Project Args: to_import: array of dicts, csv/xml string, `pandas.DataFrame` Note: If you pass a csv or xml string, you should use the `format` parameter appropriately. return_format: Response format. By default, response will be json-decoded. format: Format of incoming data. By default, to_import will be json-encoded date_format: Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. Returns: Union[int, str]: Response from REDCap API, json-decoded if `return_format == 'json'`. If successful, the number of imported fields Examples: >>> metadata = proj.export_metadata(format=\"csv\") >>> proj.import_metadata(metadata, format=\"csv\") 4 \"\"\" payload = self . _initialize_import_payload ( to_import , format , \"metadata\" ) payload [ \"returnFormat\" ] = return_format payload [ \"dateFormat\" ] = date_format response = self . _call_api ( payload , \"imp_metadata\" )[ 0 ] if \"error\" in str ( response ): raise RedcapError ( str ( response )) return response # pylint: enable=redefined-builtin def_field : str inherited property readonly The 'record_id' field equivalent for a project events : Optional [ List [ dict ]] inherited property readonly Project defined events !!! note Exists for longitudinal projects only field_names : List [ str ] inherited property readonly Project field names !!! note These are survey field names, not export field names is_longitudinal : bool inherited property readonly Whether or not this project is longitudinal metadata : List [ Dict [ str , str ]] inherited property readonly Project metadata in JSON format token : str inherited property readonly API token to your project url : str inherited property readonly API URL to your REDCap server export_metadata ( self , format = 'json' , fields = None , forms = None , df_kwargs = None ) Export the project's metadata Parameters: Name Type Description Default format Literal['json', 'csv', 'xml', 'df'] Return the metadata in native objects, csv or xml. 'df' will return a pandas.DataFrame 'json' fields Optional[List[str]] Limit exported metadata to these fields None forms Optional[List[str]] Limit exported metadata to these forms None df_kwargs Optional[Dict] Passed to pandas.read_csv to control construction of returned DataFrame. By default {'index_col': 'field_name'} None Returns: Type Description Union[str, List[Dict], pd.DataFrame] Metadata structure for the project. Examples: >>> proj . export_metadata ( format = \"df\" ) form_name section_header ... matrix_ranking field_annotation field_name ... record_id form_1 NaN ... NaN NaN field_1 form_1 NaN ... NaN NaN checkbox_field form_1 NaN ... NaN NaN upload_field form_1 NaN ... NaN NaN ... Source code in redcap/methods/metadata.py def export_metadata ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ) -> Union [ str , List [ Dict ], \"pd.DataFrame\" ]: \"\"\" Export the project's metadata Args: format: Return the metadata in native objects, csv or xml. `'df'` will return a `pandas.DataFrame` fields: Limit exported metadata to these fields forms: Limit exported metadata to these forms df_kwargs: Passed to `pandas.read_csv` to control construction of returned DataFrame. By default `{'index_col': 'field_name'}` Returns: Union[str, List[Dict], pd.DataFrame]: Metadata structure for the project. Examples: >>> proj.export_metadata(format=\"df\") form_name section_header ... matrix_ranking field_annotation field_name ... record_id form_1 NaN ... NaN NaN field_1 form_1 NaN ... NaN NaN checkbox_field form_1 NaN ... NaN NaN upload_field form_1 NaN ... NaN NaN ... \"\"\" ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"metadata\" , format = ret_format ) to_add = [ fields , forms ] str_add = [ \"fields\" , \"forms\" ] for key , data in zip ( str_add , to_add ): if data : for i , value in enumerate ( data ): payload [ f \" { key } [ { i } ]\" ] = value response , _ = self . _call_api ( payload , \"metadata\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : df_kwargs = { \"index_col\" : \"field_name\" } return self . _read_csv ( StringIO ( response ), ** df_kwargs ) import_metadata ( self , to_import , return_format = 'json' , format = 'json' , date_format = 'YMD' ) Import metadata (Data Dictionary) into the REDCap Project Parameters: Name Type Description Default to_import Union[str, List[Dict], pd.DataFrame] array of dicts, csv/xml string, pandas.DataFrame Note: If you pass a csv or xml string, you should use the format parameter appropriately. required return_format Literal['json', 'csv', 'xml'] Response format. By default, response will be json-decoded. 'json' format Literal['json', 'csv', 'xml', 'df'] Format of incoming data. By default, to_import will be json-encoded 'json' date_format Literal['YMD', 'DMY', 'MDY'] Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. 'YMD' Returns: Type Description Union[int, str] Response from REDCap API, json-decoded if return_format == 'json' . If successful, the number of imported fields Examples: >>> metadata = proj . export_metadata ( format = \"csv\" ) >>> proj . import_metadata ( metadata , format = \"csv\" ) 4 Source code in redcap/methods/metadata.py def import_metadata ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , ): \"\"\" Import metadata (Data Dictionary) into the REDCap Project Args: to_import: array of dicts, csv/xml string, `pandas.DataFrame` Note: If you pass a csv or xml string, you should use the `format` parameter appropriately. return_format: Response format. By default, response will be json-decoded. format: Format of incoming data. By default, to_import will be json-encoded date_format: Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. Returns: Union[int, str]: Response from REDCap API, json-decoded if `return_format == 'json'`. If successful, the number of imported fields Examples: >>> metadata = proj.export_metadata(format=\"csv\") >>> proj.import_metadata(metadata, format=\"csv\") 4 \"\"\" payload = self . _initialize_import_payload ( to_import , format , \"metadata\" ) payload [ \"returnFormat\" ] = return_format payload [ \"dateFormat\" ] = date_format response = self . _call_api ( payload , \"imp_metadata\" )[ 0 ] if \"error\" in str ( response ): raise RedcapError ( str ( response )) return response","title":"Metadata"},{"location":"api_reference/metadata/#metadata","text":"REDCap API methods for Project metadata","title":"Metadata"},{"location":"api_reference/metadata/#redcap.methods.metadata.Metadata","text":"Responsible for all API methods under 'Metadata' in the API Playground Source code in redcap/methods/metadata.py class Metadata ( Base ): \"\"\"Responsible for all API methods under 'Metadata' in the API Playground\"\"\" # pylint: disable=redefined-builtin @overload def export_metadata ( self , format : Literal [ \"json\" ], fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ) -> List [ Dict ]: ... @overload def export_metadata ( self , format : Literal [ \"csv\" , \"xml\" ], fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ) -> str : ... @overload def export_metadata ( self , format : Literal [ \"df\" ], fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ) -> \"pd.DataFrame\" : ... def export_metadata ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ) -> Union [ str , List [ Dict ], \"pd.DataFrame\" ]: \"\"\" Export the project's metadata Args: format: Return the metadata in native objects, csv or xml. `'df'` will return a `pandas.DataFrame` fields: Limit exported metadata to these fields forms: Limit exported metadata to these forms df_kwargs: Passed to `pandas.read_csv` to control construction of returned DataFrame. By default `{'index_col': 'field_name'}` Returns: Union[str, List[Dict], pd.DataFrame]: Metadata structure for the project. Examples: >>> proj.export_metadata(format=\"df\") form_name section_header ... matrix_ranking field_annotation field_name ... record_id form_1 NaN ... NaN NaN field_1 form_1 NaN ... NaN NaN checkbox_field form_1 NaN ... NaN NaN upload_field form_1 NaN ... NaN NaN ... \"\"\" ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"metadata\" , format = ret_format ) to_add = [ fields , forms ] str_add = [ \"fields\" , \"forms\" ] for key , data in zip ( str_add , to_add ): if data : for i , value in enumerate ( data ): payload [ f \" { key } [ { i } ]\" ] = value response , _ = self . _call_api ( payload , \"metadata\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : df_kwargs = { \"index_col\" : \"field_name\" } return self . _read_csv ( StringIO ( response ), ** df_kwargs ) @overload def import_metadata ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"json\" ], format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , ) -> int : ... @overload def import_metadata ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"csv\" , \"xml\" ], format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , ) -> str : ... def import_metadata ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , ): \"\"\" Import metadata (Data Dictionary) into the REDCap Project Args: to_import: array of dicts, csv/xml string, `pandas.DataFrame` Note: If you pass a csv or xml string, you should use the `format` parameter appropriately. return_format: Response format. By default, response will be json-decoded. format: Format of incoming data. By default, to_import will be json-encoded date_format: Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. Returns: Union[int, str]: Response from REDCap API, json-decoded if `return_format == 'json'`. If successful, the number of imported fields Examples: >>> metadata = proj.export_metadata(format=\"csv\") >>> proj.import_metadata(metadata, format=\"csv\") 4 \"\"\" payload = self . _initialize_import_payload ( to_import , format , \"metadata\" ) payload [ \"returnFormat\" ] = return_format payload [ \"dateFormat\" ] = date_format response = self . _call_api ( payload , \"imp_metadata\" )[ 0 ] if \"error\" in str ( response ): raise RedcapError ( str ( response )) return response # pylint: enable=redefined-builtin","title":"Metadata"},{"location":"api_reference/metadata/#redcap.methods.metadata.Metadata.def_field","text":"The 'record_id' field equivalent for a project","title":"def_field"},{"location":"api_reference/metadata/#redcap.methods.metadata.Metadata.events","text":"Project defined events !!! note Exists for longitudinal projects only","title":"events"},{"location":"api_reference/metadata/#redcap.methods.metadata.Metadata.field_names","text":"Project field names !!! note These are survey field names, not export field names","title":"field_names"},{"location":"api_reference/metadata/#redcap.methods.metadata.Metadata.is_longitudinal","text":"Whether or not this project is longitudinal","title":"is_longitudinal"},{"location":"api_reference/metadata/#redcap.methods.metadata.Metadata.metadata","text":"Project metadata in JSON format","title":"metadata"},{"location":"api_reference/metadata/#redcap.methods.metadata.Metadata.token","text":"API token to your project","title":"token"},{"location":"api_reference/metadata/#redcap.methods.metadata.Metadata.url","text":"API URL to your REDCap server","title":"url"},{"location":"api_reference/metadata/#redcap.methods.metadata.Metadata.export_metadata","text":"Export the project's metadata Parameters: Name Type Description Default format Literal['json', 'csv', 'xml', 'df'] Return the metadata in native objects, csv or xml. 'df' will return a pandas.DataFrame 'json' fields Optional[List[str]] Limit exported metadata to these fields None forms Optional[List[str]] Limit exported metadata to these forms None df_kwargs Optional[Dict] Passed to pandas.read_csv to control construction of returned DataFrame. By default {'index_col': 'field_name'} None Returns: Type Description Union[str, List[Dict], pd.DataFrame] Metadata structure for the project. Examples: >>> proj . export_metadata ( format = \"df\" ) form_name section_header ... matrix_ranking field_annotation field_name ... record_id form_1 NaN ... NaN NaN field_1 form_1 NaN ... NaN NaN checkbox_field form_1 NaN ... NaN NaN upload_field form_1 NaN ... NaN NaN ... Source code in redcap/methods/metadata.py def export_metadata ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ) -> Union [ str , List [ Dict ], \"pd.DataFrame\" ]: \"\"\" Export the project's metadata Args: format: Return the metadata in native objects, csv or xml. `'df'` will return a `pandas.DataFrame` fields: Limit exported metadata to these fields forms: Limit exported metadata to these forms df_kwargs: Passed to `pandas.read_csv` to control construction of returned DataFrame. By default `{'index_col': 'field_name'}` Returns: Union[str, List[Dict], pd.DataFrame]: Metadata structure for the project. Examples: >>> proj.export_metadata(format=\"df\") form_name section_header ... matrix_ranking field_annotation field_name ... record_id form_1 NaN ... NaN NaN field_1 form_1 NaN ... NaN NaN checkbox_field form_1 NaN ... NaN NaN upload_field form_1 NaN ... NaN NaN ... \"\"\" ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"metadata\" , format = ret_format ) to_add = [ fields , forms ] str_add = [ \"fields\" , \"forms\" ] for key , data in zip ( str_add , to_add ): if data : for i , value in enumerate ( data ): payload [ f \" { key } [ { i } ]\" ] = value response , _ = self . _call_api ( payload , \"metadata\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : df_kwargs = { \"index_col\" : \"field_name\" } return self . _read_csv ( StringIO ( response ), ** df_kwargs )","title":"export_metadata()"},{"location":"api_reference/metadata/#redcap.methods.metadata.Metadata.import_metadata","text":"Import metadata (Data Dictionary) into the REDCap Project Parameters: Name Type Description Default to_import Union[str, List[Dict], pd.DataFrame] array of dicts, csv/xml string, pandas.DataFrame Note: If you pass a csv or xml string, you should use the format parameter appropriately. required return_format Literal['json', 'csv', 'xml'] Response format. By default, response will be json-decoded. 'json' format Literal['json', 'csv', 'xml', 'df'] Format of incoming data. By default, to_import will be json-encoded 'json' date_format Literal['YMD', 'DMY', 'MDY'] Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. 'YMD' Returns: Type Description Union[int, str] Response from REDCap API, json-decoded if return_format == 'json' . If successful, the number of imported fields Examples: >>> metadata = proj . export_metadata ( format = \"csv\" ) >>> proj . import_metadata ( metadata , format = \"csv\" ) 4 Source code in redcap/methods/metadata.py def import_metadata ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , ): \"\"\" Import metadata (Data Dictionary) into the REDCap Project Args: to_import: array of dicts, csv/xml string, `pandas.DataFrame` Note: If you pass a csv or xml string, you should use the `format` parameter appropriately. return_format: Response format. By default, response will be json-decoded. format: Format of incoming data. By default, to_import will be json-encoded date_format: Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. Returns: Union[int, str]: Response from REDCap API, json-decoded if `return_format == 'json'`. If successful, the number of imported fields Examples: >>> metadata = proj.export_metadata(format=\"csv\") >>> proj.import_metadata(metadata, format=\"csv\") 4 \"\"\" payload = self . _initialize_import_payload ( to_import , format , \"metadata\" ) payload [ \"returnFormat\" ] = return_format payload [ \"dateFormat\" ] = date_format response = self . _call_api ( payload , \"imp_metadata\" )[ 0 ] if \"error\" in str ( response ): raise RedcapError ( str ( response )) return response","title":"import_metadata()"},{"location":"api_reference/project/","text":"Project User facing class for interacting with a REDCap Project Project ( FieldNames , Files , Instruments , Metadata , ProjectInfo , Records , Reports , Surveys , Users , Version ) Main class for interacting with REDCap projects Attributes: Name Type Description verify_ssl Verify SSL, default True. Can pass path to CA_BUNDLE !!! note Your REDCap token should be kept secret ! Treat it like a password and NEVER save it directly in your script/application. Rather it should be obscured and retrieved 'behind the scenes'. For example, saving the token as an environment variable and retrieving it with os.getenv . The creation of the TOKEN string in the example is not shown, for the above reasons Examples: >>> from redcap import Project >>> URL = \"https://redcapdemo.vanderbilt.edu/api/\" >>> proj = Project ( URL , TOKEN ) >>> proj . field_names [ 'record_id' , 'field_1' , 'checkbox_field' , 'upload_field' ] >>> proj . is_longitudinal True >>> proj . def_field 'record_id' The url and token attributes are read-only, to prevent users from accidentally overwriting them >>> proj . url = \"whoops\" Traceback ( most recent call last ): ... AttributeError : can 't set attribute Source code in redcap/project.py class Project ( methods . field_names . FieldNames , methods . files . Files , methods . instruments . Instruments , methods . metadata . Metadata , methods . project_info . ProjectInfo , methods . records . Records , methods . reports . Reports , methods . surveys . Surveys , methods . users . Users , methods . version . Version , ): \"\"\"Main class for interacting with REDCap projects Attributes: verify_ssl: Verify SSL, default True. Can pass path to CA_BUNDLE Note: Your REDCap token should be kept **secret**! Treat it like a password and NEVER save it directly in your script/application. Rather it should be obscured and retrieved 'behind the scenes'. For example, saving the token as an environment variable and retrieving it with `os.getenv`. The creation of the `TOKEN` string in the example is not shown, for the above reasons Examples: >>> from redcap import Project >>> URL = \"https://redcapdemo.vanderbilt.edu/api/\" >>> proj = Project(URL, TOKEN) >>> proj.field_names ['record_id', 'field_1', 'checkbox_field', 'upload_field'] >>> proj.is_longitudinal True >>> proj.def_field 'record_id' The url and token attributes are read-only, to prevent users from accidentally overwriting them >>> proj.url = \"whoops\" Traceback (most recent call last): ... AttributeError: can't set attribute \"\"\" @property def redcap_version ( self ) -> Optional [ semantic_version . Version ]: \"\"\"REDCap version of the Project\"\"\" self . _redcap_version : Optional [ semantic_version . Version ] try : return self . _redcap_version except AttributeError : self . _redcap_version = self . export_version () return self . _redcap_version def_field : str inherited property readonly The 'record_id' field equivalent for a project events : Optional [ List [ dict ]] inherited property readonly Project defined events !!! note Exists for longitudinal projects only field_names : List [ str ] inherited property readonly Project field names !!! note These are survey field names, not export field names is_longitudinal : bool inherited property readonly Whether or not this project is longitudinal metadata : List [ Dict [ str , str ]] inherited property readonly Project metadata in JSON format redcap_version : Optional [ semantic_version . base . Version ] property readonly REDCap version of the Project token : str inherited property readonly API token to your project url : str inherited property readonly API URL to your REDCap server delete_file ( self , record , field , event = None , return_format = 'json' ) inherited Delete a file from REDCap !!! note There is no undo button to this. Parameters: Name Type Description Default record str Record ID required field str Field name required event Optional[str] For longitudinal projects, the unique event name None return_format str 'json' , 'csv' , 'xml' Return format for error message 'json' Returns: Type Description Union[Dict, Literal['']] Response from REDCap after deleting file Examples: Import a tempfile and then delete it >>> import tempfile >>> tmp_file = tempfile . TemporaryFile () >>> proj . import_file ( ... record = \"2\" , ... field = \"upload_field\" , ... file_name = \"myupload.txt\" , ... file_object = tmp_file , ... event = \"event_1_arm_1\" , ... ) {} >>> proj . delete_file ( record = \"2\" , field = \"upload_field\" , event = \"event_1_arm_1\" ) {} Source code in redcap/project.py def delete_file ( self , record : str , field : str , event : Optional [ str ] = None , return_format : str = \"json\" , ) -> Union [ Dict , Literal [ \"\" ]]: \"\"\" Delete a file from REDCap Note: There is no undo button to this. Args: record: Record ID field: Field name event: For longitudinal projects, the unique event name return_format: `'json'`, `'csv'`, `'xml'` Return format for error message Returns: Response from REDCap after deleting file Examples: Import a tempfile and then delete it >>> import tempfile >>> tmp_file = tempfile.TemporaryFile() >>> proj.import_file( ... record=\"2\", ... field=\"upload_field\", ... file_name=\"myupload.txt\", ... file_object=tmp_file, ... event=\"event_1_arm_1\", ... ) {} >>> proj.delete_file(record=\"2\", field=\"upload_field\", event=\"event_1_arm_1\") {} \"\"\" self . _check_file_field ( field ) # Load up payload payload = self . _basepl ( content = \"file\" , format = return_format ) del payload [ \"format\" ] payload [ \"returnFormat\" ] = return_format payload [ \"action\" ] = \"delete\" payload [ \"record\" ] = record payload [ \"field\" ] = field if event : payload [ \"event\" ] = event return self . _call_api ( payload , \"del_file\" )[ 0 ] delete_records ( self , records ) inherited Delete records from the project. Parameters: Name Type Description Default records List[str] List of record IDs to delete from the project required Returns: Type Description int Number of records deleted Examples: >>> new_record = [{ \"record_id\" : 3 , \"field_1\" : 1 }, { \"record_id\" : 4 }] >>> proj . import_records ( new_record ) { 'count' : 2 } >>> proj . delete_records ([ \"3\" , \"4\" ]) '2' Source code in redcap/project.py def delete_records ( self , records : List [ str ]) -> int : \"\"\" Delete records from the project. Args: records: List of record IDs to delete from the project Returns: Number of records deleted Examples: >>> new_record = [{\"record_id\": 3, \"field_1\": 1}, {\"record_id\": 4}] >>> proj.import_records(new_record) {'count': 2} >>> proj.delete_records([\"3\", \"4\"]) '2' \"\"\" payload = {} payload [ \"action\" ] = \"delete\" payload [ \"content\" ] = \"record\" payload [ \"token\" ] = self . token # Turn list of records into dict, and append to payload records_dict = { f \"records[ { idx } ]\" : record for idx , record in enumerate ( records ) } payload . update ( records_dict ) payload [ \"format\" ] = format response , _ = self . _call_api ( payload , \"del_record\" ) return response # pylint: disable=redefined-builtin export_field_names ( self , field = None , format = 'json' , df_kwargs = None ) inherited Export the project's export field names Parameters: Name Type Description Default field Optional[str] Limit exported field name to this field (only single field supported). When not provided, all fields returned None format str 'json' , 'csv' , 'xml' , 'df' Return the metadata in native objects, csv or xml. 'df' will return a pandas.DataFrame 'json' df_kwargs Optional[Dict] Passed to pandas.read_csv to control construction of returned DataFrame. by default {'index_col': 'original_field_name'} None Returns: Type Description Union[str, List[Dict], \"pd.DataFrame\"] Metadata structure for the project. Examples: >>> proj . export_field_names () [{ 'original_field_name' : 'record_id' , 'choice_value' : '' , 'export_field_name' : 'record_id' }, { 'original_field_name' : 'field_1' , 'choice_value' : '' , 'export_field_name' : 'field_1' }, { 'original_field_name' : 'checkbox_field' , 'choice_value' : '1' , 'export_field_name' : 'checkbox_field___1' }, { 'original_field_name' : 'checkbox_field' , 'choice_value' : '2' , 'export_field_name' : 'checkbox_field___2' }, { 'original_field_name' : 'form_1_complete' , 'choice_value' : '' , 'export_field_name' : 'form_1_complete' }] Source code in redcap/project.py def export_field_names ( self , field : Optional [ str ] = None , format : str = \"json\" , df_kwargs : Optional [ Dict ] = None , ): \"\"\" Export the project's export field names Args: field: Limit exported field name to this field (only single field supported). When not provided, all fields returned format: `'json'`, `'csv'`, `'xml'`, `'df'` Return the metadata in native objects, csv or xml. `'df'` will return a `pandas.DataFrame` df_kwargs: Passed to `pandas.read_csv` to control construction of returned DataFrame. by default `{'index_col': 'original_field_name'}` Returns: Union[str, List[Dict], \"pd.DataFrame\"]: Metadata structure for the project. Examples: >>> proj.export_field_names() [{'original_field_name': 'record_id', 'choice_value': '', 'export_field_name': 'record_id'}, {'original_field_name': 'field_1', 'choice_value': '', 'export_field_name': 'field_1'}, {'original_field_name': 'checkbox_field', 'choice_value': '1', 'export_field_name': 'checkbox_field___1'}, {'original_field_name': 'checkbox_field', 'choice_value': '2', 'export_field_name': 'checkbox_field___2'}, {'original_field_name': 'form_1_complete', 'choice_value': '', 'export_field_name': 'form_1_complete'}] \"\"\" # pylint: disable=line-too-long # pylint: enable=line-too-long ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"exportFieldNames\" , format = ret_format ) if field : payload [ \"field\" ] = field response , _ = self . _call_api ( payload , \"exp_field_names\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : df_kwargs = { \"index_col\" : \"original_field_name\" } return self . _read_csv ( StringIO ( response ), ** df_kwargs ) export_file ( self , record , field , event = None , return_format = 'json' , repeat_instance = None ) inherited Export the contents of a file stored for a particular record !!! note Unlike other export methods, this only works on a single record. Parameters: Name Type Description Default record str Record ID required field str Field name containing the file to be exported. required event Optional[str] For longitudinal projects, the unique event name None return_format str 'json' , 'csv' , 'xml' Format of error message 'json' repeat_instance Optional[int] (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). None Returns: Type Description Tuple[bytes, Dict] Content of the file and content-type dictionary Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> proj . export_file ( record = \"1\" , field = \"upload_field\" , event = \"event_1_arm_1\" ) ( b 'test upload \\n ' , { 'name' : 'test_upload.txt' , 'charset' : 'UTF-8' }) Source code in redcap/project.py def export_file ( self , record : str , field : str , event : Optional [ str ] = None , return_format : str = \"json\" , repeat_instance : Optional [ int ] = None , ) -> Tuple [ bytes , Dict ]: \"\"\" Export the contents of a file stored for a particular record Note: Unlike other export methods, this only works on a single record. Args: record: Record ID field: Field name containing the file to be exported. event: For longitudinal projects, the unique event name return_format: `'json'`, `'csv'`, `'xml'` Format of error message repeat_instance: (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). Returns: Content of the file and content-type dictionary Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> proj.export_file(record=\"1\", field=\"upload_field\", event=\"event_1_arm_1\") (b'test upload\\\\n', {'name': 'test_upload.txt', 'charset': 'UTF-8'}) \"\"\" assert self . _check_file_field ( field ) # load up payload payload = self . _basepl ( content = \"file\" , format = return_format ) # there's no format field in this call del payload [ \"format\" ] payload [ \"returnFormat\" ] = return_format payload [ \"action\" ] = \"export\" payload [ \"field\" ] = field payload [ \"record\" ] = record if event : payload [ \"event\" ] = event if repeat_instance : payload [ \"repeat_instance\" ] = str ( repeat_instance ) content , headers = self . _call_api ( payload , \"exp_file\" ) # REDCap adds some useful things in content-type content_map = {} if \"content-type\" in headers : splat = [ key_values . strip () for key_values in headers [ \"content-type\" ] . split ( \";\" ) ] key_values = [ ( key_values . split ( \"=\" )[ 0 ], key_values . split ( \"=\" )[ 1 ] . replace ( '\"' , \"\" )) for key_values in splat if \"=\" in key_values ] content_map = dict ( key_values ) return content , content_map export_instrument_event_mappings ( self , format = 'json' , arms = None , df_kwargs = None ) inherited Export the project's instrument to event mapping Parameters: Name Type Description Default format Literal['json', 'csv', 'xml', 'df'] Return the form event mappings in native objects, csv or xml, 'df'' will return a pandas.DataFrame 'json' arms Optional[List[str]] Limit exported form event mappings to these arm numbers None df_kwargs Optional[Dict] Passed to pandas.read_csv to control construction of returned DataFrame None Returns: Type Description Union[str, List[Dict], pd.DataFrame] Instrument-event mapping for the project Examples: >>> proj . export_instrument_event_mappings () [{ 'arm_num' : 1 , 'unique_event_name' : 'event_1_arm_1' , 'form' : 'form_1' }] Source code in redcap/project.py def export_instrument_event_mappings ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , arms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ): \"\"\" Export the project's instrument to event mapping Args: format: Return the form event mappings in native objects, csv or xml, `'df''` will return a `pandas.DataFrame` arms: Limit exported form event mappings to these arm numbers df_kwargs: Passed to pandas.read_csv to control construction of returned DataFrame Returns: Union[str, List[Dict], pd.DataFrame]: Instrument-event mapping for the project Examples: >>> proj.export_instrument_event_mappings() [{'arm_num': 1, 'unique_event_name': 'event_1_arm_1', 'form': 'form_1'}] \"\"\" ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"formEventMapping\" , format = ret_format ) if arms : for i , value in enumerate ( arms ): payload [ f \"arms[ { i } ]\" ] = value response , _ = self . _call_api ( payload , \"exp_fem\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : df_kwargs = {} return self . _read_csv ( StringIO ( response ), ** df_kwargs ) export_metadata ( self , format = 'json' , fields = None , forms = None , df_kwargs = None ) inherited Export the project's metadata Parameters: Name Type Description Default format Literal['json', 'csv', 'xml', 'df'] Return the metadata in native objects, csv or xml. 'df' will return a pandas.DataFrame 'json' fields Optional[List[str]] Limit exported metadata to these fields None forms Optional[List[str]] Limit exported metadata to these forms None df_kwargs Optional[Dict] Passed to pandas.read_csv to control construction of returned DataFrame. By default {'index_col': 'field_name'} None Returns: Type Description Union[str, List[Dict], pd.DataFrame] Metadata structure for the project. Examples: >>> proj . export_metadata ( format = \"df\" ) form_name section_header ... matrix_ranking field_annotation field_name ... record_id form_1 NaN ... NaN NaN field_1 form_1 NaN ... NaN NaN checkbox_field form_1 NaN ... NaN NaN upload_field form_1 NaN ... NaN NaN ... Source code in redcap/project.py def export_metadata ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ) -> Union [ str , List [ Dict ], \"pd.DataFrame\" ]: \"\"\" Export the project's metadata Args: format: Return the metadata in native objects, csv or xml. `'df'` will return a `pandas.DataFrame` fields: Limit exported metadata to these fields forms: Limit exported metadata to these forms df_kwargs: Passed to `pandas.read_csv` to control construction of returned DataFrame. By default `{'index_col': 'field_name'}` Returns: Union[str, List[Dict], pd.DataFrame]: Metadata structure for the project. Examples: >>> proj.export_metadata(format=\"df\") form_name section_header ... matrix_ranking field_annotation field_name ... record_id form_1 NaN ... NaN NaN field_1 form_1 NaN ... NaN NaN checkbox_field form_1 NaN ... NaN NaN upload_field form_1 NaN ... NaN NaN ... \"\"\" ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"metadata\" , format = ret_format ) to_add = [ fields , forms ] str_add = [ \"fields\" , \"forms\" ] for key , data in zip ( str_add , to_add ): if data : for i , value in enumerate ( data ): payload [ f \" { key } [ { i } ]\" ] = value response , _ = self . _call_api ( payload , \"metadata\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : df_kwargs = { \"index_col\" : \"field_name\" } return self . _read_csv ( StringIO ( response ), ** df_kwargs ) export_project_info ( self , format = 'json' ) inherited Export Project Information Parameters: Name Type Description Default format Literal['json', 'csv', 'xml'] Format of returned data 'json' Returns: Type Description Union[str, List[Dict]] Project information Examples: >>> proj . export_project_info () { 'project_id' : ... ... 'in_production' : 0 , 'project_language' : 'English' , 'purpose' : 0 , 'purpose_other' : '' , ... 'project_grant_number' : '' , 'project_pi_firstname' : '' , 'project_pi_lastname' : '' , ... 'bypass_branching_erase_field_prompt' : 0 } Source code in redcap/project.py def export_project_info ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" ): \"\"\" Export Project Information Args: format: Format of returned data Returns: Union[str, List[Dict]]: Project information Examples: >>> proj.export_project_info() {'project_id': ... ... 'in_production': 0, 'project_language': 'English', 'purpose': 0, 'purpose_other': '', ... 'project_grant_number': '', 'project_pi_firstname': '', 'project_pi_lastname': '', ... 'bypass_branching_erase_field_prompt': 0} \"\"\" payload = self . _basepl ( content = \"project\" , format = format ) return self . _call_api ( payload , \"exp_proj\" )[ 0 ] export_records ( self , format = 'json' , records = None , fields = None , forms = None , events = None , raw_or_label = 'raw' , event_name = 'label' , type = 'flat' , export_survey_fields = False , export_data_access_groups = False , df_kwargs = None , export_checkbox_labels = False , filter_logic = None , date_begin = None , date_end = None ) inherited Export data from the REDCap project. Parameters: Name Type Description Default format Literal['json', 'csv', 'xml', 'df'] Format of returned data. 'json' returns json-decoded objects while 'csv' and 'xml' return other formats. 'df' will attempt to return a pandas.DataFrame 'json' records Optional[List[str]] Array of record names specifying specific records to export. By default, all records are exported None fields Optional[List[str]] Array of field names specifying specific fields to pull by default, all fields are exported None forms Optional[List[str]] Array of form names to export. If in the web UI, the form name has a space in it, replace the space with an underscore By default, all forms are exported None events Optional[List[str]] An array of unique event names from which to export records Note: This only applies to longitudinal projects None raw_or_label Literal['raw', 'label', 'both'] Export the raw coded values or labels for the options of multiple choice fields, or both 'raw' event_name Literal['label', 'unique'] Export the unique event name or the event label 'label' type Literal['flat', 'eav'] Database output structure type 'flat' export_survey_fields bool Specifies whether or not to export the survey identifier field (e.g., \"redcap_survey_identifier\") or survey timestamp fields (e.g., form_name+\"_timestamp\") when surveys are utilized in the project False export_data_access_groups bool Specifies whether or not to export the \"redcap_data_access_group\" field when data access groups are utilized in the project Note: This flag is only viable if the user whose token is being used to make the API request is not in a data access group. If the user is in a group, then this flag will revert to its default value. False df_kwargs Optional[Dict] Passed to pandas.read_csv to control construction of returned DataFrame. By default, {'index_col': self.def_field} None export_checkbox_labels bool Specify whether to export checkbox values as their label on export. False filter_logic Optional[str] Filter which records are returned using REDCap conditional syntax None date_begin Optional[datetime.datetime] Filter on records created after a date None date_end Optional[datetime.datetime] Filter on records created before a date None Returns: Type Description Union[List[Dict], str, pd.DataFrame] Exported data Examples: >>> proj . export_records () [{ 'record_id' : '1' , 'redcap_event_name' : 'event_1_arm_1' , 'field_1' : '1' , 'checkbox_field___1' : '0' , 'checkbox_field___2' : '1' , 'upload_field' : 'test_upload.txt' , 'form_1_complete' : '2' }, { 'record_id' : '2' , 'redcap_event_name' : 'event_1_arm_1' , 'field_1' : '0' , 'checkbox_field___1' : '0' , 'checkbox_field___2' : '0' , 'upload_field' : 'myupload.txt' , 'form_1_complete' : '0' }] >>> proj . export_records ( filter_logic = \"[field_1] = 1\" ) [{ 'record_id' : '1' , 'redcap_event_name' : 'event_1_arm_1' , 'field_1' : '1' , 'checkbox_field___1' : '0' , 'checkbox_field___2' : '1' , 'upload_field' : 'test_upload.txt' , 'form_1_complete' : '2' }] >>> proj . export_records ( ... format = \"csv\" , ... fields = [ \"field_1\" , \"checkbox_field\" ], ... raw_or_label = \"label\" ... ) 'field_1,checkbox_field___1,checkbox_field___2 \\n Yes,Unchecked,Checked \\n No,Unchecked,Unchecked \\n ' >>> import pandas as pd >>> pd . set_option ( \"display.max_columns\" , 3 ) >>> proj . export_records ( format = \"df\" ) field_1 ... form_1_complete record_id redcap_event_name ... 1 event_1_arm_1 1 ... 2 2 event_1_arm_1 0 ... 0 ... Source code in redcap/project.py def export_records ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , records : Optional [ List [ str ]] = None , fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , events : Optional [ List [ str ]] = None , raw_or_label : Literal [ \"raw\" , \"label\" , \"both\" ] = \"raw\" , event_name : Literal [ \"label\" , \"unique\" ] = \"label\" , type : Literal [ \"flat\" , \"eav\" ] = \"flat\" , export_survey_fields : bool = False , export_data_access_groups : bool = False , df_kwargs : Optional [ Dict ] = None , export_checkbox_labels : bool = False , filter_logic : Optional [ str ] = None , date_begin : Optional [ datetime ] = None , date_end : Optional [ datetime ] = None , ): \"\"\" Export data from the REDCap project. Args: format: Format of returned data. `'json'` returns json-decoded objects while `'csv'` and `'xml'` return other formats. `'df'` will attempt to return a `pandas.DataFrame` records: Array of record names specifying specific records to export. By default, all records are exported fields: Array of field names specifying specific fields to pull by default, all fields are exported forms: Array of form names to export. If in the web UI, the form name has a space in it, replace the space with an underscore By default, all forms are exported events: An array of unique event names from which to export records Note: This only applies to longitudinal projects raw_or_label: Export the raw coded values or labels for the options of multiple choice fields, or both event_name: Export the unique event name or the event label type: Database output structure type export_survey_fields: Specifies whether or not to export the survey identifier field (e.g., \"redcap_survey_identifier\") or survey timestamp fields (e.g., form_name+\"_timestamp\") when surveys are utilized in the project export_data_access_groups: Specifies whether or not to export the `\"redcap_data_access_group\"` field when data access groups are utilized in the project Note: This flag is only viable if the user whose token is being used to make the API request is *not* in a data access group. If the user is in a group, then this flag will revert to its default value. df_kwargs: Passed to `pandas.read_csv` to control construction of returned DataFrame. By default, `{'index_col': self.def_field}` export_checkbox_labels: Specify whether to export checkbox values as their label on export. filter_logic: Filter which records are returned using REDCap conditional syntax date_begin: Filter on records created after a date date_end: Filter on records created before a date Returns: Union[List[Dict], str, pd.DataFrame]: Exported data Examples: >>> proj.export_records() [{'record_id': '1', 'redcap_event_name': 'event_1_arm_1', 'field_1': '1', 'checkbox_field___1': '0', 'checkbox_field___2': '1', 'upload_field': 'test_upload.txt', 'form_1_complete': '2'}, {'record_id': '2', 'redcap_event_name': 'event_1_arm_1', 'field_1': '0', 'checkbox_field___1': '0', 'checkbox_field___2': '0', 'upload_field': 'myupload.txt', 'form_1_complete': '0'}] >>> proj.export_records(filter_logic=\"[field_1] = 1\") [{'record_id': '1', 'redcap_event_name': 'event_1_arm_1', 'field_1': '1', 'checkbox_field___1': '0', 'checkbox_field___2': '1', 'upload_field': 'test_upload.txt', 'form_1_complete': '2'}] >>> proj.export_records( ... format=\"csv\", ... fields=[\"field_1\", \"checkbox_field\"], ... raw_or_label=\"label\" ... ) 'field_1,checkbox_field___1,checkbox_field___2\\\\nYes,Unchecked,Checked\\\\nNo,Unchecked,Unchecked\\\\n' >>> import pandas as pd >>> pd.set_option(\"display.max_columns\", 3) >>> proj.export_records(format=\"df\") field_1 ... form_1_complete record_id redcap_event_name ... 1 event_1_arm_1 1 ... 2 2 event_1_arm_1 0 ... 0 ... \"\"\" # pylint: disable=line-too-long # pylint: enable=line-too-long ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"record\" , format = ret_format , rec_type = type ) keys_to_add = ( records , fields , forms , events , raw_or_label , event_name , export_survey_fields , export_data_access_groups , export_checkbox_labels , ) str_keys = ( \"records\" , \"fields\" , \"forms\" , \"events\" , \"rawOrLabel\" , \"eventName\" , \"exportSurveyFields\" , \"exportDataAccessGroups\" , \"exportCheckboxLabel\" , ) for key , data in zip ( str_keys , keys_to_add ): if data : if key in ( \"fields\" , \"records\" , \"forms\" , \"events\" ): for i , value in enumerate ( data ): payload [ f \" { key } [ { i } ]\" ] = value else : payload [ key ] = data if date_begin : payload [ \"dateRangeBegin\" ] = date_begin . strftime ( \"%Y-%m- %d %H:%M:%S\" ) if date_end : payload [ \"dateRangeEnd\" ] = date_end . strftime ( \"%Y-%m- %d %H:%M:%S\" ) if filter_logic : payload [ \"filterLogic\" ] = filter_logic response , _ = self . _call_api ( payload , \"exp_record\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : if type == \"eav\" : df_kwargs = {} else : if self . is_longitudinal : df_kwargs = { \"index_col\" : [ self . def_field , \"redcap_event_name\" ]} else : df_kwargs = { \"index_col\" : self . def_field } buf = StringIO ( response ) dataframe = self . _read_csv ( buf , ** df_kwargs ) buf . close () return dataframe export_report ( self , report_id , format = 'json' , raw_or_label = 'raw' , raw_or_label_headers = 'raw' , export_checkbox_labels = False , csv_delimiter = ',' , df_kwargs = None ) inherited Export a report of the Project Parameters: Name Type Description Default report_id str The report ID number provided next to the report name on the report list page required format Literal['json', 'csv', 'xml', 'df'] Format of returned data. 'json' returns json-decoded objects while 'csv' and 'xml' return strings. 'df' will attempt to return a pandas.DataFrame . 'json' raw_or_label Literal['raw', 'label'] Export the raw coded values or labels for the options of multiple choice fields 'raw' raw_or_label_headers Literal['raw', 'label'] For the CSV headers, export the variable/field names (raw) or the field labels (label) 'raw' export_checkbox_labels bool Specifies the format of checkbox field values specifically when exporting the data as labels (i.e. when rawOrLabel=label ). When exporting labels, by default (without providing the exportCheckboxLabel flag or if exportCheckboxLabel=false), all checkboxes will either have a value 'Checked' if they are checked or 'Unchecked' if not checked. But if exportCheckboxLabel is set to true, it will instead export the checkbox value as the checkbox option's label (e.g., 'Choice 1') if checked or it will be blank/empty (no value) if not checked False csv_delimiter Literal[',', 'tab', ';', '|', '^'] For the csv format, choose how the csv delimiter. ',' Exceptions: Type Description ValueError Unsupported format specified Returns: Type Description Union[List[Dict], str, pd.DataFrame] Data from the report ordered by the record (primary key of project) and then by event id Examples: >>> proj . export_report ( report_id = \"4292\" ) # doctest: +SKIP [{ 'record_id' : '1' , 'redcap_event_name' : 'event_1_arm_1' , 'checkbox_field___1' : '0' , 'checkbox_field___2' : '1' }] Source code in redcap/project.py def export_report ( self , report_id : str , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , raw_or_label : Literal [ \"raw\" , \"label\" ] = \"raw\" , raw_or_label_headers : Literal [ \"raw\" , \"label\" ] = \"raw\" , export_checkbox_labels : bool = False , csv_delimiter : Literal [ \",\" , \"tab\" , \";\" , \"|\" , \"^\" ] = \",\" , df_kwargs : Optional [ Dict ] = None , ): \"\"\" Export a report of the Project Args: report_id: The report ID number provided next to the report name on the report list page format: Format of returned data. `'json'` returns json-decoded objects while `'csv'` and `'xml'` return strings. `'df'` will attempt to return a `pandas.DataFrame`. raw_or_label: Export the raw coded values or labels for the options of multiple choice fields raw_or_label_headers: For the CSV headers, export the variable/field names (raw) or the field labels (label) export_checkbox_labels: Specifies the format of checkbox field values specifically when exporting the data as labels (i.e. when `rawOrLabel=label`). When exporting labels, by default (without providing the exportCheckboxLabel flag or if exportCheckboxLabel=false), all checkboxes will either have a value 'Checked' if they are checked or 'Unchecked' if not checked. But if exportCheckboxLabel is set to true, it will instead export the checkbox value as the checkbox option's label (e.g., 'Choice 1') if checked or it will be blank/empty (no value) if not checked csv_delimiter: For the csv format, choose how the csv delimiter. Raises: ValueError: Unsupported format specified Returns: Union[List[Dict], str, pd.DataFrame]: Data from the report ordered by the record (primary key of project) and then by event id Examples: >>> proj.export_report(report_id=\"4292\") # doctest: +SKIP [{'record_id': '1', 'redcap_event_name': 'event_1_arm_1', 'checkbox_field___1': '0', 'checkbox_field___2': '1'}] \"\"\" ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( content = \"report\" , format = ret_format ) keys_to_add = ( report_id , raw_or_label , raw_or_label_headers , export_checkbox_labels , csv_delimiter , ) str_keys = ( \"report_id\" , \"rawOrLabel\" , \"rawOrLabelHeaders\" , \"exportCheckboxLabel\" , \"csvDelimiter\" , ) for key , data in zip ( str_keys , keys_to_add ): if data : payload [ key ] = data response , _ = self . _call_api ( payload , \"exp_report\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : if self . is_longitudinal : df_kwargs = { \"index_col\" : [ self . def_field , \"redcap_event_name\" ]} else : df_kwargs = { \"index_col\" : self . def_field } buf = StringIO ( response ) dataframe = self . _read_csv ( buf , ** df_kwargs ) buf . close () return dataframe export_survey_participant_list ( self , instrument , format = 'json' , event = None ) inherited Export the Survey Participant List !!! note The passed instrument must be set up as a survey instrument. Parameters: Name Type Description Default instrument str Name of instrument as seen in the Data Dictionary (metadata). required format Literal['json', 'csv', 'xml'] Format of returned data 'json' event Optional[str] Unique event name, only used in longitudinal projects None Returns: Type Description Union[List[Dict], str] List of survey participants, along with other useful metadata such as the record, response status, etc. Examples: >>> proj . export_survey_participant_list ( instrument = \"form_1\" , event = \"event_1_arm_1\" ) [{ 'email' : '' , ... 'survey_access_code' : ... }, { 'email' : '' , ... 'survey_access_code' : ... }] Source code in redcap/project.py def export_survey_participant_list ( self , instrument : str , format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" , event : Optional [ str ] = None , ): \"\"\" Export the Survey Participant List Note: The passed instrument must be set up as a survey instrument. Args: instrument: Name of instrument as seen in the Data Dictionary (metadata). format: Format of returned data event: Unique event name, only used in longitudinal projects Returns: Union[List[Dict], str]: List of survey participants, along with other useful metadata such as the record, response status, etc. Examples: >>> proj.export_survey_participant_list(instrument=\"form_1\", event=\"event_1_arm_1\") [{'email': '', ... 'survey_access_code': ...}, {'email': '', ... 'survey_access_code': ...}] \"\"\" # pylint: disable=line-too-long # pylint: enable=line-too-long payload = self . _basepl ( content = \"participantList\" , format = format ) payload [ \"instrument\" ] = instrument if event : payload [ \"event\" ] = event return self . _call_api ( payload , \"exp_survey_participant_list\" )[ 0 ] # pylint: enable=redefined-builtin export_users ( self , format = 'json' ) inherited Export the users of the Project !!! note Each user will have the following keys: * `'firstname'` : User's first name * `'lastname'` : User's last name * `'email'` : Email address * `'username'` : User's username * `'expiration'` : Project access expiration date * `'data_access_group'` : data access group ID * `'data_export'` : (0=no access, 2=De-Identified, 1=Full Data Set) * `'forms'` : a list of dicts with a single key as the form name and value is an integer describing that user's form rights, where: 0=no access, 1=view records/responses and edit records (survey responses are read-only), 2=read only, and 3=edit survey responses, Parameters: Name Type Description Default format Literal['json', 'csv', 'xml'] Response return format 'json' Returns: Type Description Union[List[Dict], str] List of users with metadata Examples: >>> proj . export_users () [{ 'username' : ... , 'email' : ... , 'expiration' : '' , 'data_access_group' : '' , 'data_access_group_id' : '' , 'design' : 1 , 'user_rights' : 1 , 'data_access_groups' : 1 , 'data_export' : 1 , ... }] Source code in redcap/project.py def export_users ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" ): \"\"\" Export the users of the Project Note: Each user will have the following keys: * `'firstname'` : User's first name * `'lastname'` : User's last name * `'email'` : Email address * `'username'` : User's username * `'expiration'` : Project access expiration date * `'data_access_group'` : data access group ID * `'data_export'` : (0=no access, 2=De-Identified, 1=Full Data Set) * `'forms'` : a list of dicts with a single key as the form name and value is an integer describing that user's form rights, where: 0=no access, 1=view records/responses and edit records (survey responses are read-only), 2=read only, and 3=edit survey responses, Args: format: Response return format Returns: Union[List[Dict], str]: List of users with metadata Examples: >>> proj.export_users() [{'username': ..., 'email': ..., 'expiration': '', 'data_access_group': '', 'data_access_group_id': '', 'design': 1, 'user_rights': 1, 'data_access_groups': 1, 'data_export': 1, ...}] \"\"\" payload = self . _basepl ( content = \"user\" , format = format ) return self . _call_api ( payload , \"exp_user\" )[ 0 ] # pylint: enable=redefined-builtin export_version ( self ) inherited Get the REDCap version Returns: Type Description Optional[semantic_version.base.Version] REDCap version running on the url provided Examples: >>> import semantic_version >>> redcap_version = proj . export_version () >>> assert redcap_version >= semantic_version . Version ( \"12.0.1\" ) Source code in redcap/project.py def export_version ( self ) -> Optional [ semantic_version . Version ]: \"\"\" Get the REDCap version Returns: REDCap version running on the url provided Examples: >>> import semantic_version >>> redcap_version = proj.export_version() >>> assert redcap_version >= semantic_version.Version(\"12.0.1\") \"\"\" payload = self . _basepl ( \"version\" ) redcap_version = self . _call_api ( payload , \"version\" )[ 0 ] . decode ( \"utf-8\" ) resp : Optional [ semantic_version . Version ] = None if \"error\" in redcap_version : warnings . warn ( \"Version information not available for this REDCap instance\" ) if semantic_version . validate ( redcap_version ): resp = semantic_version . Version ( redcap_version ) return resp generate_next_record_name ( self ) inherited Get the next record name Returns: Type Description int The next record name for a project with auto-numbering records enabled Examples: >>> proj . generate_next_record_name () 3 Source code in redcap/project.py def generate_next_record_name ( self ) -> int : \"\"\" Get the next record name Returns: The next record name for a project with auto-numbering records enabled Examples: >>> proj.generate_next_record_name() 3 \"\"\" payload = self . _basepl ( content = \"generateNextRecordName\" ) return self . _call_api ( payload , \"exp_next_id\" )[ 0 ] import_file ( self , record , field , file_name , file_object , event = None , repeat_instance = None , return_format = 'json' ) inherited Import the contents of a file represented by file_object to a particular records field Parameters: Name Type Description Default record str Record ID required field str Field name where the file will go required file_name str File name visible in REDCap UI required file_object TextIOWrapper File object as returned by open required event Optional[str] For longitudinal projects, the unique event name None repeat_instance Union[int, str] (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). None return_format str 'json' , 'csv' , 'xml' Format of error message 'json' Returns: Type Description Union[Dict, Literal['']] Response from server as specified by return_format Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> import tempfile >>> tmp_file = tempfile . TemporaryFile () >>> proj . import_file ( ... record = \"2\" , ... field = \"upload_field\" , ... file_name = \"myupload.txt\" , ... file_object = tmp_file , ... event = \"event_1_arm_1\" , ... ) {} Source code in redcap/project.py def import_file ( self , record : str , field : str , file_name : str , file_object : \"TextIOWrapper\" , event : Optional [ str ] = None , repeat_instance : Optional [ Union [ int , str ]] = None , return_format : str = \"json\" , ) -> Union [ Dict , Literal [ \"\" ]]: \"\"\" Import the contents of a file represented by file_object to a particular records field Args: record: Record ID field: Field name where the file will go file_name: File name visible in REDCap UI file_object: File object as returned by `open` event: For longitudinal projects, the unique event name repeat_instance: (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). return_format: `'json'`, `'csv'`, `'xml'` Format of error message Returns: Response from server as specified by `return_format` Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> import tempfile >>> tmp_file = tempfile.TemporaryFile() >>> proj.import_file( ... record=\"2\", ... field=\"upload_field\", ... file_name=\"myupload.txt\", ... file_object=tmp_file, ... event=\"event_1_arm_1\", ... ) {} \"\"\" self . _check_file_field ( field ) # load up payload payload = self . _basepl ( content = \"file\" , format = return_format ) # no format in this call del payload [ \"format\" ] payload [ \"returnFormat\" ] = return_format payload [ \"action\" ] = \"import\" payload [ \"field\" ] = field payload [ \"record\" ] = record if event : payload [ \"event\" ] = event if repeat_instance : payload [ \"repeat_instance\" ] = repeat_instance file_kwargs = { \"files\" : { \"file\" : ( file_name , file_object )}} return self . _call_api ( payload , \"imp_file\" , ** file_kwargs )[ 0 ] import_metadata ( self , to_import , return_format = 'json' , format = 'json' , date_format = 'YMD' ) inherited Import metadata (Data Dictionary) into the REDCap Project Parameters: Name Type Description Default to_import Union[str, List[Dict], pd.DataFrame] array of dicts, csv/xml string, pandas.DataFrame Note: If you pass a csv or xml string, you should use the format parameter appropriately. required return_format Literal['json', 'csv', 'xml'] Response format. By default, response will be json-decoded. 'json' format Literal['json', 'csv', 'xml', 'df'] Format of incoming data. By default, to_import will be json-encoded 'json' date_format Literal['YMD', 'DMY', 'MDY'] Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. 'YMD' Returns: Type Description Union[int, str] Response from REDCap API, json-decoded if return_format == 'json' . If successful, the number of imported fields Examples: >>> metadata = proj . export_metadata ( format = \"csv\" ) >>> proj . import_metadata ( metadata , format = \"csv\" ) 4 Source code in redcap/project.py def import_metadata ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , ): \"\"\" Import metadata (Data Dictionary) into the REDCap Project Args: to_import: array of dicts, csv/xml string, `pandas.DataFrame` Note: If you pass a csv or xml string, you should use the `format` parameter appropriately. return_format: Response format. By default, response will be json-decoded. format: Format of incoming data. By default, to_import will be json-encoded date_format: Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. Returns: Union[int, str]: Response from REDCap API, json-decoded if `return_format == 'json'`. If successful, the number of imported fields Examples: >>> metadata = proj.export_metadata(format=\"csv\") >>> proj.import_metadata(metadata, format=\"csv\") 4 \"\"\" payload = self . _initialize_import_payload ( to_import , format , \"metadata\" ) payload [ \"returnFormat\" ] = return_format payload [ \"dateFormat\" ] = date_format response = self . _call_api ( payload , \"imp_metadata\" )[ 0 ] if \"error\" in str ( response ): raise RedcapError ( str ( response )) return response import_records ( self , to_import , return_format = 'json' , overwrite = 'normal' , format = 'json' , return_content = 'count' , date_format = 'YMD' , force_auto_number = False ) inherited Import data into the RedCap Project Parameters: Name Type Description Default to_import Union[str, List[Dict], pd.DataFrame] Note: If you pass a df, csv, or xml string, you should use the format parameter appropriately. Note: Keys of the dictionaries should be subset of project's, fields, but this isn't a requirement. If you provide keys that aren't defined fields, the returned response will contain an 'error' key. required return_format Literal['json', 'csv', 'xml'] Response format. By default, response will be json-decoded. 'json' overwrite Literal['normal', 'overwrite'] 'overwrite' will erase values previously stored in the database if not specified in the to_import dictionaries. 'normal' format Literal['json', 'csv', 'xml', 'df'] Format of incoming data. By default, to_import will be json-encoded 'json' return_content Literal['count', 'ids', 'nothing'] By default, the response contains a 'count' key with the number of records just imported. By specifying 'ids', a list of ids imported will be returned. 'nothing' will only return the HTTP status code and no message. 'count' date_format Literal['YMD', 'DMY', 'MDY'] Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. 'YMD' force_auto_number bool Enables automatic assignment of record IDs of imported records by REDCap. If this is set to true, and auto-numbering for records is enabled for the project, auto-numbering of imported records will be enabled. False Exceptions: Type Description RedcapError Bad request made, double check field names and inputs Returns: Type Description Union[Dict, str] response from REDCap API, json-decoded if return_format == 'json' Examples: >>> new_record = [{ \"record_id\" : 3 , \"field_1\" : 1 }] >>> proj . import_records ( new_record ) { 'count' : 1 } Source code in redcap/project.py def import_records ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" , overwrite : Literal [ \"normal\" , \"overwrite\" ] = \"normal\" , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , return_content : Literal [ \"count\" , \"ids\" , \"nothing\" ] = \"count\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , force_auto_number : bool = False , ): \"\"\" Import data into the RedCap Project Args: to_import: Note: If you pass a df, csv, or xml string, you should use the `format` parameter appropriately. Note: Keys of the dictionaries should be subset of project's, fields, but this isn't a requirement. If you provide keys that aren't defined fields, the returned response will contain an `'error'` key. return_format: Response format. By default, response will be json-decoded. overwrite: `'overwrite'` will erase values previously stored in the database if not specified in the to_import dictionaries. format: Format of incoming data. By default, to_import will be json-encoded return_content: By default, the response contains a 'count' key with the number of records just imported. By specifying 'ids', a list of ids imported will be returned. 'nothing' will only return the HTTP status code and no message. date_format: Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. force_auto_number: Enables automatic assignment of record IDs of imported records by REDCap. If this is set to true, and auto-numbering for records is enabled for the project, auto-numbering of imported records will be enabled. Raises: RedcapError: Bad request made, double check field names and inputs Returns: Union[Dict, str]: response from REDCap API, json-decoded if `return_format` == `'json'` Examples: >>> new_record = [{\"record_id\": 3, \"field_1\": 1}] >>> proj.import_records(new_record) {'count': 1} \"\"\" payload = self . _initialize_import_payload ( to_import , format , \"record\" ) payload [ \"overwriteBehavior\" ] = overwrite payload [ \"returnFormat\" ] = return_format payload [ \"returnContent\" ] = return_content payload [ \"dateFormat\" ] = date_format payload [ \"forceAutoNumber\" ] = force_auto_number response = self . _call_api ( payload , \"imp_record\" )[ 0 ] if \"error\" in response : raise RedcapError ( str ( response )) return response","title":"Project"},{"location":"api_reference/project/#project","text":"User facing class for interacting with a REDCap Project","title":"Project"},{"location":"api_reference/project/#redcap.project.Project","text":"Main class for interacting with REDCap projects Attributes: Name Type Description verify_ssl Verify SSL, default True. Can pass path to CA_BUNDLE !!! note Your REDCap token should be kept secret ! Treat it like a password and NEVER save it directly in your script/application. Rather it should be obscured and retrieved 'behind the scenes'. For example, saving the token as an environment variable and retrieving it with os.getenv . The creation of the TOKEN string in the example is not shown, for the above reasons Examples: >>> from redcap import Project >>> URL = \"https://redcapdemo.vanderbilt.edu/api/\" >>> proj = Project ( URL , TOKEN ) >>> proj . field_names [ 'record_id' , 'field_1' , 'checkbox_field' , 'upload_field' ] >>> proj . is_longitudinal True >>> proj . def_field 'record_id' The url and token attributes are read-only, to prevent users from accidentally overwriting them >>> proj . url = \"whoops\" Traceback ( most recent call last ): ... AttributeError : can 't set attribute Source code in redcap/project.py class Project ( methods . field_names . FieldNames , methods . files . Files , methods . instruments . Instruments , methods . metadata . Metadata , methods . project_info . ProjectInfo , methods . records . Records , methods . reports . Reports , methods . surveys . Surveys , methods . users . Users , methods . version . Version , ): \"\"\"Main class for interacting with REDCap projects Attributes: verify_ssl: Verify SSL, default True. Can pass path to CA_BUNDLE Note: Your REDCap token should be kept **secret**! Treat it like a password and NEVER save it directly in your script/application. Rather it should be obscured and retrieved 'behind the scenes'. For example, saving the token as an environment variable and retrieving it with `os.getenv`. The creation of the `TOKEN` string in the example is not shown, for the above reasons Examples: >>> from redcap import Project >>> URL = \"https://redcapdemo.vanderbilt.edu/api/\" >>> proj = Project(URL, TOKEN) >>> proj.field_names ['record_id', 'field_1', 'checkbox_field', 'upload_field'] >>> proj.is_longitudinal True >>> proj.def_field 'record_id' The url and token attributes are read-only, to prevent users from accidentally overwriting them >>> proj.url = \"whoops\" Traceback (most recent call last): ... AttributeError: can't set attribute \"\"\" @property def redcap_version ( self ) -> Optional [ semantic_version . Version ]: \"\"\"REDCap version of the Project\"\"\" self . _redcap_version : Optional [ semantic_version . Version ] try : return self . _redcap_version except AttributeError : self . _redcap_version = self . export_version () return self . _redcap_version","title":"Project"},{"location":"api_reference/project/#redcap.project.Project.def_field","text":"The 'record_id' field equivalent for a project","title":"def_field"},{"location":"api_reference/project/#redcap.project.Project.events","text":"Project defined events !!! note Exists for longitudinal projects only","title":"events"},{"location":"api_reference/project/#redcap.project.Project.field_names","text":"Project field names !!! note These are survey field names, not export field names","title":"field_names"},{"location":"api_reference/project/#redcap.project.Project.is_longitudinal","text":"Whether or not this project is longitudinal","title":"is_longitudinal"},{"location":"api_reference/project/#redcap.project.Project.metadata","text":"Project metadata in JSON format","title":"metadata"},{"location":"api_reference/project/#redcap.project.Project.redcap_version","text":"REDCap version of the Project","title":"redcap_version"},{"location":"api_reference/project/#redcap.project.Project.token","text":"API token to your project","title":"token"},{"location":"api_reference/project/#redcap.project.Project.url","text":"API URL to your REDCap server","title":"url"},{"location":"api_reference/project/#redcap.project.Project.delete_file","text":"Delete a file from REDCap !!! note There is no undo button to this. Parameters: Name Type Description Default record str Record ID required field str Field name required event Optional[str] For longitudinal projects, the unique event name None return_format str 'json' , 'csv' , 'xml' Return format for error message 'json' Returns: Type Description Union[Dict, Literal['']] Response from REDCap after deleting file Examples: Import a tempfile and then delete it >>> import tempfile >>> tmp_file = tempfile . TemporaryFile () >>> proj . import_file ( ... record = \"2\" , ... field = \"upload_field\" , ... file_name = \"myupload.txt\" , ... file_object = tmp_file , ... event = \"event_1_arm_1\" , ... ) {} >>> proj . delete_file ( record = \"2\" , field = \"upload_field\" , event = \"event_1_arm_1\" ) {} Source code in redcap/project.py def delete_file ( self , record : str , field : str , event : Optional [ str ] = None , return_format : str = \"json\" , ) -> Union [ Dict , Literal [ \"\" ]]: \"\"\" Delete a file from REDCap Note: There is no undo button to this. Args: record: Record ID field: Field name event: For longitudinal projects, the unique event name return_format: `'json'`, `'csv'`, `'xml'` Return format for error message Returns: Response from REDCap after deleting file Examples: Import a tempfile and then delete it >>> import tempfile >>> tmp_file = tempfile.TemporaryFile() >>> proj.import_file( ... record=\"2\", ... field=\"upload_field\", ... file_name=\"myupload.txt\", ... file_object=tmp_file, ... event=\"event_1_arm_1\", ... ) {} >>> proj.delete_file(record=\"2\", field=\"upload_field\", event=\"event_1_arm_1\") {} \"\"\" self . _check_file_field ( field ) # Load up payload payload = self . _basepl ( content = \"file\" , format = return_format ) del payload [ \"format\" ] payload [ \"returnFormat\" ] = return_format payload [ \"action\" ] = \"delete\" payload [ \"record\" ] = record payload [ \"field\" ] = field if event : payload [ \"event\" ] = event return self . _call_api ( payload , \"del_file\" )[ 0 ]","title":"delete_file()"},{"location":"api_reference/project/#redcap.project.Project.delete_records","text":"Delete records from the project. Parameters: Name Type Description Default records List[str] List of record IDs to delete from the project required Returns: Type Description int Number of records deleted Examples: >>> new_record = [{ \"record_id\" : 3 , \"field_1\" : 1 }, { \"record_id\" : 4 }] >>> proj . import_records ( new_record ) { 'count' : 2 } >>> proj . delete_records ([ \"3\" , \"4\" ]) '2' Source code in redcap/project.py def delete_records ( self , records : List [ str ]) -> int : \"\"\" Delete records from the project. Args: records: List of record IDs to delete from the project Returns: Number of records deleted Examples: >>> new_record = [{\"record_id\": 3, \"field_1\": 1}, {\"record_id\": 4}] >>> proj.import_records(new_record) {'count': 2} >>> proj.delete_records([\"3\", \"4\"]) '2' \"\"\" payload = {} payload [ \"action\" ] = \"delete\" payload [ \"content\" ] = \"record\" payload [ \"token\" ] = self . token # Turn list of records into dict, and append to payload records_dict = { f \"records[ { idx } ]\" : record for idx , record in enumerate ( records ) } payload . update ( records_dict ) payload [ \"format\" ] = format response , _ = self . _call_api ( payload , \"del_record\" ) return response # pylint: disable=redefined-builtin","title":"delete_records()"},{"location":"api_reference/project/#redcap.project.Project.export_field_names","text":"Export the project's export field names Parameters: Name Type Description Default field Optional[str] Limit exported field name to this field (only single field supported). When not provided, all fields returned None format str 'json' , 'csv' , 'xml' , 'df' Return the metadata in native objects, csv or xml. 'df' will return a pandas.DataFrame 'json' df_kwargs Optional[Dict] Passed to pandas.read_csv to control construction of returned DataFrame. by default {'index_col': 'original_field_name'} None Returns: Type Description Union[str, List[Dict], \"pd.DataFrame\"] Metadata structure for the project. Examples: >>> proj . export_field_names () [{ 'original_field_name' : 'record_id' , 'choice_value' : '' , 'export_field_name' : 'record_id' }, { 'original_field_name' : 'field_1' , 'choice_value' : '' , 'export_field_name' : 'field_1' }, { 'original_field_name' : 'checkbox_field' , 'choice_value' : '1' , 'export_field_name' : 'checkbox_field___1' }, { 'original_field_name' : 'checkbox_field' , 'choice_value' : '2' , 'export_field_name' : 'checkbox_field___2' }, { 'original_field_name' : 'form_1_complete' , 'choice_value' : '' , 'export_field_name' : 'form_1_complete' }] Source code in redcap/project.py def export_field_names ( self , field : Optional [ str ] = None , format : str = \"json\" , df_kwargs : Optional [ Dict ] = None , ): \"\"\" Export the project's export field names Args: field: Limit exported field name to this field (only single field supported). When not provided, all fields returned format: `'json'`, `'csv'`, `'xml'`, `'df'` Return the metadata in native objects, csv or xml. `'df'` will return a `pandas.DataFrame` df_kwargs: Passed to `pandas.read_csv` to control construction of returned DataFrame. by default `{'index_col': 'original_field_name'}` Returns: Union[str, List[Dict], \"pd.DataFrame\"]: Metadata structure for the project. Examples: >>> proj.export_field_names() [{'original_field_name': 'record_id', 'choice_value': '', 'export_field_name': 'record_id'}, {'original_field_name': 'field_1', 'choice_value': '', 'export_field_name': 'field_1'}, {'original_field_name': 'checkbox_field', 'choice_value': '1', 'export_field_name': 'checkbox_field___1'}, {'original_field_name': 'checkbox_field', 'choice_value': '2', 'export_field_name': 'checkbox_field___2'}, {'original_field_name': 'form_1_complete', 'choice_value': '', 'export_field_name': 'form_1_complete'}] \"\"\" # pylint: disable=line-too-long # pylint: enable=line-too-long ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"exportFieldNames\" , format = ret_format ) if field : payload [ \"field\" ] = field response , _ = self . _call_api ( payload , \"exp_field_names\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : df_kwargs = { \"index_col\" : \"original_field_name\" } return self . _read_csv ( StringIO ( response ), ** df_kwargs )","title":"export_field_names()"},{"location":"api_reference/project/#redcap.project.Project.export_file","text":"Export the contents of a file stored for a particular record !!! note Unlike other export methods, this only works on a single record. Parameters: Name Type Description Default record str Record ID required field str Field name containing the file to be exported. required event Optional[str] For longitudinal projects, the unique event name None return_format str 'json' , 'csv' , 'xml' Format of error message 'json' repeat_instance Optional[int] (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). None Returns: Type Description Tuple[bytes, Dict] Content of the file and content-type dictionary Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> proj . export_file ( record = \"1\" , field = \"upload_field\" , event = \"event_1_arm_1\" ) ( b 'test upload \\n ' , { 'name' : 'test_upload.txt' , 'charset' : 'UTF-8' }) Source code in redcap/project.py def export_file ( self , record : str , field : str , event : Optional [ str ] = None , return_format : str = \"json\" , repeat_instance : Optional [ int ] = None , ) -> Tuple [ bytes , Dict ]: \"\"\" Export the contents of a file stored for a particular record Note: Unlike other export methods, this only works on a single record. Args: record: Record ID field: Field name containing the file to be exported. event: For longitudinal projects, the unique event name return_format: `'json'`, `'csv'`, `'xml'` Format of error message repeat_instance: (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). Returns: Content of the file and content-type dictionary Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> proj.export_file(record=\"1\", field=\"upload_field\", event=\"event_1_arm_1\") (b'test upload\\\\n', {'name': 'test_upload.txt', 'charset': 'UTF-8'}) \"\"\" assert self . _check_file_field ( field ) # load up payload payload = self . _basepl ( content = \"file\" , format = return_format ) # there's no format field in this call del payload [ \"format\" ] payload [ \"returnFormat\" ] = return_format payload [ \"action\" ] = \"export\" payload [ \"field\" ] = field payload [ \"record\" ] = record if event : payload [ \"event\" ] = event if repeat_instance : payload [ \"repeat_instance\" ] = str ( repeat_instance ) content , headers = self . _call_api ( payload , \"exp_file\" ) # REDCap adds some useful things in content-type content_map = {} if \"content-type\" in headers : splat = [ key_values . strip () for key_values in headers [ \"content-type\" ] . split ( \";\" ) ] key_values = [ ( key_values . split ( \"=\" )[ 0 ], key_values . split ( \"=\" )[ 1 ] . replace ( '\"' , \"\" )) for key_values in splat if \"=\" in key_values ] content_map = dict ( key_values ) return content , content_map","title":"export_file()"},{"location":"api_reference/project/#redcap.project.Project.export_instrument_event_mappings","text":"Export the project's instrument to event mapping Parameters: Name Type Description Default format Literal['json', 'csv', 'xml', 'df'] Return the form event mappings in native objects, csv or xml, 'df'' will return a pandas.DataFrame 'json' arms Optional[List[str]] Limit exported form event mappings to these arm numbers None df_kwargs Optional[Dict] Passed to pandas.read_csv to control construction of returned DataFrame None Returns: Type Description Union[str, List[Dict], pd.DataFrame] Instrument-event mapping for the project Examples: >>> proj . export_instrument_event_mappings () [{ 'arm_num' : 1 , 'unique_event_name' : 'event_1_arm_1' , 'form' : 'form_1' }] Source code in redcap/project.py def export_instrument_event_mappings ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , arms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ): \"\"\" Export the project's instrument to event mapping Args: format: Return the form event mappings in native objects, csv or xml, `'df''` will return a `pandas.DataFrame` arms: Limit exported form event mappings to these arm numbers df_kwargs: Passed to pandas.read_csv to control construction of returned DataFrame Returns: Union[str, List[Dict], pd.DataFrame]: Instrument-event mapping for the project Examples: >>> proj.export_instrument_event_mappings() [{'arm_num': 1, 'unique_event_name': 'event_1_arm_1', 'form': 'form_1'}] \"\"\" ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"formEventMapping\" , format = ret_format ) if arms : for i , value in enumerate ( arms ): payload [ f \"arms[ { i } ]\" ] = value response , _ = self . _call_api ( payload , \"exp_fem\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : df_kwargs = {} return self . _read_csv ( StringIO ( response ), ** df_kwargs )","title":"export_instrument_event_mappings()"},{"location":"api_reference/project/#redcap.project.Project.export_metadata","text":"Export the project's metadata Parameters: Name Type Description Default format Literal['json', 'csv', 'xml', 'df'] Return the metadata in native objects, csv or xml. 'df' will return a pandas.DataFrame 'json' fields Optional[List[str]] Limit exported metadata to these fields None forms Optional[List[str]] Limit exported metadata to these forms None df_kwargs Optional[Dict] Passed to pandas.read_csv to control construction of returned DataFrame. By default {'index_col': 'field_name'} None Returns: Type Description Union[str, List[Dict], pd.DataFrame] Metadata structure for the project. Examples: >>> proj . export_metadata ( format = \"df\" ) form_name section_header ... matrix_ranking field_annotation field_name ... record_id form_1 NaN ... NaN NaN field_1 form_1 NaN ... NaN NaN checkbox_field form_1 NaN ... NaN NaN upload_field form_1 NaN ... NaN NaN ... Source code in redcap/project.py def export_metadata ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , df_kwargs : Optional [ Dict ] = None , ) -> Union [ str , List [ Dict ], \"pd.DataFrame\" ]: \"\"\" Export the project's metadata Args: format: Return the metadata in native objects, csv or xml. `'df'` will return a `pandas.DataFrame` fields: Limit exported metadata to these fields forms: Limit exported metadata to these forms df_kwargs: Passed to `pandas.read_csv` to control construction of returned DataFrame. By default `{'index_col': 'field_name'}` Returns: Union[str, List[Dict], pd.DataFrame]: Metadata structure for the project. Examples: >>> proj.export_metadata(format=\"df\") form_name section_header ... matrix_ranking field_annotation field_name ... record_id form_1 NaN ... NaN NaN field_1 form_1 NaN ... NaN NaN checkbox_field form_1 NaN ... NaN NaN upload_field form_1 NaN ... NaN NaN ... \"\"\" ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"metadata\" , format = ret_format ) to_add = [ fields , forms ] str_add = [ \"fields\" , \"forms\" ] for key , data in zip ( str_add , to_add ): if data : for i , value in enumerate ( data ): payload [ f \" { key } [ { i } ]\" ] = value response , _ = self . _call_api ( payload , \"metadata\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : df_kwargs = { \"index_col\" : \"field_name\" } return self . _read_csv ( StringIO ( response ), ** df_kwargs )","title":"export_metadata()"},{"location":"api_reference/project/#redcap.project.Project.export_project_info","text":"Export Project Information Parameters: Name Type Description Default format Literal['json', 'csv', 'xml'] Format of returned data 'json' Returns: Type Description Union[str, List[Dict]] Project information Examples: >>> proj . export_project_info () { 'project_id' : ... ... 'in_production' : 0 , 'project_language' : 'English' , 'purpose' : 0 , 'purpose_other' : '' , ... 'project_grant_number' : '' , 'project_pi_firstname' : '' , 'project_pi_lastname' : '' , ... 'bypass_branching_erase_field_prompt' : 0 } Source code in redcap/project.py def export_project_info ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" ): \"\"\" Export Project Information Args: format: Format of returned data Returns: Union[str, List[Dict]]: Project information Examples: >>> proj.export_project_info() {'project_id': ... ... 'in_production': 0, 'project_language': 'English', 'purpose': 0, 'purpose_other': '', ... 'project_grant_number': '', 'project_pi_firstname': '', 'project_pi_lastname': '', ... 'bypass_branching_erase_field_prompt': 0} \"\"\" payload = self . _basepl ( content = \"project\" , format = format ) return self . _call_api ( payload , \"exp_proj\" )[ 0 ]","title":"export_project_info()"},{"location":"api_reference/project/#redcap.project.Project.export_records","text":"Export data from the REDCap project. Parameters: Name Type Description Default format Literal['json', 'csv', 'xml', 'df'] Format of returned data. 'json' returns json-decoded objects while 'csv' and 'xml' return other formats. 'df' will attempt to return a pandas.DataFrame 'json' records Optional[List[str]] Array of record names specifying specific records to export. By default, all records are exported None fields Optional[List[str]] Array of field names specifying specific fields to pull by default, all fields are exported None forms Optional[List[str]] Array of form names to export. If in the web UI, the form name has a space in it, replace the space with an underscore By default, all forms are exported None events Optional[List[str]] An array of unique event names from which to export records Note: This only applies to longitudinal projects None raw_or_label Literal['raw', 'label', 'both'] Export the raw coded values or labels for the options of multiple choice fields, or both 'raw' event_name Literal['label', 'unique'] Export the unique event name or the event label 'label' type Literal['flat', 'eav'] Database output structure type 'flat' export_survey_fields bool Specifies whether or not to export the survey identifier field (e.g., \"redcap_survey_identifier\") or survey timestamp fields (e.g., form_name+\"_timestamp\") when surveys are utilized in the project False export_data_access_groups bool Specifies whether or not to export the \"redcap_data_access_group\" field when data access groups are utilized in the project Note: This flag is only viable if the user whose token is being used to make the API request is not in a data access group. If the user is in a group, then this flag will revert to its default value. False df_kwargs Optional[Dict] Passed to pandas.read_csv to control construction of returned DataFrame. By default, {'index_col': self.def_field} None export_checkbox_labels bool Specify whether to export checkbox values as their label on export. False filter_logic Optional[str] Filter which records are returned using REDCap conditional syntax None date_begin Optional[datetime.datetime] Filter on records created after a date None date_end Optional[datetime.datetime] Filter on records created before a date None Returns: Type Description Union[List[Dict], str, pd.DataFrame] Exported data Examples: >>> proj . export_records () [{ 'record_id' : '1' , 'redcap_event_name' : 'event_1_arm_1' , 'field_1' : '1' , 'checkbox_field___1' : '0' , 'checkbox_field___2' : '1' , 'upload_field' : 'test_upload.txt' , 'form_1_complete' : '2' }, { 'record_id' : '2' , 'redcap_event_name' : 'event_1_arm_1' , 'field_1' : '0' , 'checkbox_field___1' : '0' , 'checkbox_field___2' : '0' , 'upload_field' : 'myupload.txt' , 'form_1_complete' : '0' }] >>> proj . export_records ( filter_logic = \"[field_1] = 1\" ) [{ 'record_id' : '1' , 'redcap_event_name' : 'event_1_arm_1' , 'field_1' : '1' , 'checkbox_field___1' : '0' , 'checkbox_field___2' : '1' , 'upload_field' : 'test_upload.txt' , 'form_1_complete' : '2' }] >>> proj . export_records ( ... format = \"csv\" , ... fields = [ \"field_1\" , \"checkbox_field\" ], ... raw_or_label = \"label\" ... ) 'field_1,checkbox_field___1,checkbox_field___2 \\n Yes,Unchecked,Checked \\n No,Unchecked,Unchecked \\n ' >>> import pandas as pd >>> pd . set_option ( \"display.max_columns\" , 3 ) >>> proj . export_records ( format = \"df\" ) field_1 ... form_1_complete record_id redcap_event_name ... 1 event_1_arm_1 1 ... 2 2 event_1_arm_1 0 ... 0 ... Source code in redcap/project.py def export_records ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , records : Optional [ List [ str ]] = None , fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , events : Optional [ List [ str ]] = None , raw_or_label : Literal [ \"raw\" , \"label\" , \"both\" ] = \"raw\" , event_name : Literal [ \"label\" , \"unique\" ] = \"label\" , type : Literal [ \"flat\" , \"eav\" ] = \"flat\" , export_survey_fields : bool = False , export_data_access_groups : bool = False , df_kwargs : Optional [ Dict ] = None , export_checkbox_labels : bool = False , filter_logic : Optional [ str ] = None , date_begin : Optional [ datetime ] = None , date_end : Optional [ datetime ] = None , ): \"\"\" Export data from the REDCap project. Args: format: Format of returned data. `'json'` returns json-decoded objects while `'csv'` and `'xml'` return other formats. `'df'` will attempt to return a `pandas.DataFrame` records: Array of record names specifying specific records to export. By default, all records are exported fields: Array of field names specifying specific fields to pull by default, all fields are exported forms: Array of form names to export. If in the web UI, the form name has a space in it, replace the space with an underscore By default, all forms are exported events: An array of unique event names from which to export records Note: This only applies to longitudinal projects raw_or_label: Export the raw coded values or labels for the options of multiple choice fields, or both event_name: Export the unique event name or the event label type: Database output structure type export_survey_fields: Specifies whether or not to export the survey identifier field (e.g., \"redcap_survey_identifier\") or survey timestamp fields (e.g., form_name+\"_timestamp\") when surveys are utilized in the project export_data_access_groups: Specifies whether or not to export the `\"redcap_data_access_group\"` field when data access groups are utilized in the project Note: This flag is only viable if the user whose token is being used to make the API request is *not* in a data access group. If the user is in a group, then this flag will revert to its default value. df_kwargs: Passed to `pandas.read_csv` to control construction of returned DataFrame. By default, `{'index_col': self.def_field}` export_checkbox_labels: Specify whether to export checkbox values as their label on export. filter_logic: Filter which records are returned using REDCap conditional syntax date_begin: Filter on records created after a date date_end: Filter on records created before a date Returns: Union[List[Dict], str, pd.DataFrame]: Exported data Examples: >>> proj.export_records() [{'record_id': '1', 'redcap_event_name': 'event_1_arm_1', 'field_1': '1', 'checkbox_field___1': '0', 'checkbox_field___2': '1', 'upload_field': 'test_upload.txt', 'form_1_complete': '2'}, {'record_id': '2', 'redcap_event_name': 'event_1_arm_1', 'field_1': '0', 'checkbox_field___1': '0', 'checkbox_field___2': '0', 'upload_field': 'myupload.txt', 'form_1_complete': '0'}] >>> proj.export_records(filter_logic=\"[field_1] = 1\") [{'record_id': '1', 'redcap_event_name': 'event_1_arm_1', 'field_1': '1', 'checkbox_field___1': '0', 'checkbox_field___2': '1', 'upload_field': 'test_upload.txt', 'form_1_complete': '2'}] >>> proj.export_records( ... format=\"csv\", ... fields=[\"field_1\", \"checkbox_field\"], ... raw_or_label=\"label\" ... ) 'field_1,checkbox_field___1,checkbox_field___2\\\\nYes,Unchecked,Checked\\\\nNo,Unchecked,Unchecked\\\\n' >>> import pandas as pd >>> pd.set_option(\"display.max_columns\", 3) >>> proj.export_records(format=\"df\") field_1 ... form_1_complete record_id redcap_event_name ... 1 event_1_arm_1 1 ... 2 2 event_1_arm_1 0 ... 0 ... \"\"\" # pylint: disable=line-too-long # pylint: enable=line-too-long ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"record\" , format = ret_format , rec_type = type ) keys_to_add = ( records , fields , forms , events , raw_or_label , event_name , export_survey_fields , export_data_access_groups , export_checkbox_labels , ) str_keys = ( \"records\" , \"fields\" , \"forms\" , \"events\" , \"rawOrLabel\" , \"eventName\" , \"exportSurveyFields\" , \"exportDataAccessGroups\" , \"exportCheckboxLabel\" , ) for key , data in zip ( str_keys , keys_to_add ): if data : if key in ( \"fields\" , \"records\" , \"forms\" , \"events\" ): for i , value in enumerate ( data ): payload [ f \" { key } [ { i } ]\" ] = value else : payload [ key ] = data if date_begin : payload [ \"dateRangeBegin\" ] = date_begin . strftime ( \"%Y-%m- %d %H:%M:%S\" ) if date_end : payload [ \"dateRangeEnd\" ] = date_end . strftime ( \"%Y-%m- %d %H:%M:%S\" ) if filter_logic : payload [ \"filterLogic\" ] = filter_logic response , _ = self . _call_api ( payload , \"exp_record\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : if type == \"eav\" : df_kwargs = {} else : if self . is_longitudinal : df_kwargs = { \"index_col\" : [ self . def_field , \"redcap_event_name\" ]} else : df_kwargs = { \"index_col\" : self . def_field } buf = StringIO ( response ) dataframe = self . _read_csv ( buf , ** df_kwargs ) buf . close () return dataframe","title":"export_records()"},{"location":"api_reference/project/#redcap.project.Project.export_report","text":"Export a report of the Project Parameters: Name Type Description Default report_id str The report ID number provided next to the report name on the report list page required format Literal['json', 'csv', 'xml', 'df'] Format of returned data. 'json' returns json-decoded objects while 'csv' and 'xml' return strings. 'df' will attempt to return a pandas.DataFrame . 'json' raw_or_label Literal['raw', 'label'] Export the raw coded values or labels for the options of multiple choice fields 'raw' raw_or_label_headers Literal['raw', 'label'] For the CSV headers, export the variable/field names (raw) or the field labels (label) 'raw' export_checkbox_labels bool Specifies the format of checkbox field values specifically when exporting the data as labels (i.e. when rawOrLabel=label ). When exporting labels, by default (without providing the exportCheckboxLabel flag or if exportCheckboxLabel=false), all checkboxes will either have a value 'Checked' if they are checked or 'Unchecked' if not checked. But if exportCheckboxLabel is set to true, it will instead export the checkbox value as the checkbox option's label (e.g., 'Choice 1') if checked or it will be blank/empty (no value) if not checked False csv_delimiter Literal[',', 'tab', ';', '|', '^'] For the csv format, choose how the csv delimiter. ',' Exceptions: Type Description ValueError Unsupported format specified Returns: Type Description Union[List[Dict], str, pd.DataFrame] Data from the report ordered by the record (primary key of project) and then by event id Examples: >>> proj . export_report ( report_id = \"4292\" ) # doctest: +SKIP [{ 'record_id' : '1' , 'redcap_event_name' : 'event_1_arm_1' , 'checkbox_field___1' : '0' , 'checkbox_field___2' : '1' }] Source code in redcap/project.py def export_report ( self , report_id : str , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , raw_or_label : Literal [ \"raw\" , \"label\" ] = \"raw\" , raw_or_label_headers : Literal [ \"raw\" , \"label\" ] = \"raw\" , export_checkbox_labels : bool = False , csv_delimiter : Literal [ \",\" , \"tab\" , \";\" , \"|\" , \"^\" ] = \",\" , df_kwargs : Optional [ Dict ] = None , ): \"\"\" Export a report of the Project Args: report_id: The report ID number provided next to the report name on the report list page format: Format of returned data. `'json'` returns json-decoded objects while `'csv'` and `'xml'` return strings. `'df'` will attempt to return a `pandas.DataFrame`. raw_or_label: Export the raw coded values or labels for the options of multiple choice fields raw_or_label_headers: For the CSV headers, export the variable/field names (raw) or the field labels (label) export_checkbox_labels: Specifies the format of checkbox field values specifically when exporting the data as labels (i.e. when `rawOrLabel=label`). When exporting labels, by default (without providing the exportCheckboxLabel flag or if exportCheckboxLabel=false), all checkboxes will either have a value 'Checked' if they are checked or 'Unchecked' if not checked. But if exportCheckboxLabel is set to true, it will instead export the checkbox value as the checkbox option's label (e.g., 'Choice 1') if checked or it will be blank/empty (no value) if not checked csv_delimiter: For the csv format, choose how the csv delimiter. Raises: ValueError: Unsupported format specified Returns: Union[List[Dict], str, pd.DataFrame]: Data from the report ordered by the record (primary key of project) and then by event id Examples: >>> proj.export_report(report_id=\"4292\") # doctest: +SKIP [{'record_id': '1', 'redcap_event_name': 'event_1_arm_1', 'checkbox_field___1': '0', 'checkbox_field___2': '1'}] \"\"\" ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( content = \"report\" , format = ret_format ) keys_to_add = ( report_id , raw_or_label , raw_or_label_headers , export_checkbox_labels , csv_delimiter , ) str_keys = ( \"report_id\" , \"rawOrLabel\" , \"rawOrLabelHeaders\" , \"exportCheckboxLabel\" , \"csvDelimiter\" , ) for key , data in zip ( str_keys , keys_to_add ): if data : payload [ key ] = data response , _ = self . _call_api ( payload , \"exp_report\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : if self . is_longitudinal : df_kwargs = { \"index_col\" : [ self . def_field , \"redcap_event_name\" ]} else : df_kwargs = { \"index_col\" : self . def_field } buf = StringIO ( response ) dataframe = self . _read_csv ( buf , ** df_kwargs ) buf . close () return dataframe","title":"export_report()"},{"location":"api_reference/project/#redcap.project.Project.export_survey_participant_list","text":"Export the Survey Participant List !!! note The passed instrument must be set up as a survey instrument. Parameters: Name Type Description Default instrument str Name of instrument as seen in the Data Dictionary (metadata). required format Literal['json', 'csv', 'xml'] Format of returned data 'json' event Optional[str] Unique event name, only used in longitudinal projects None Returns: Type Description Union[List[Dict], str] List of survey participants, along with other useful metadata such as the record, response status, etc. Examples: >>> proj . export_survey_participant_list ( instrument = \"form_1\" , event = \"event_1_arm_1\" ) [{ 'email' : '' , ... 'survey_access_code' : ... }, { 'email' : '' , ... 'survey_access_code' : ... }] Source code in redcap/project.py def export_survey_participant_list ( self , instrument : str , format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" , event : Optional [ str ] = None , ): \"\"\" Export the Survey Participant List Note: The passed instrument must be set up as a survey instrument. Args: instrument: Name of instrument as seen in the Data Dictionary (metadata). format: Format of returned data event: Unique event name, only used in longitudinal projects Returns: Union[List[Dict], str]: List of survey participants, along with other useful metadata such as the record, response status, etc. Examples: >>> proj.export_survey_participant_list(instrument=\"form_1\", event=\"event_1_arm_1\") [{'email': '', ... 'survey_access_code': ...}, {'email': '', ... 'survey_access_code': ...}] \"\"\" # pylint: disable=line-too-long # pylint: enable=line-too-long payload = self . _basepl ( content = \"participantList\" , format = format ) payload [ \"instrument\" ] = instrument if event : payload [ \"event\" ] = event return self . _call_api ( payload , \"exp_survey_participant_list\" )[ 0 ] # pylint: enable=redefined-builtin","title":"export_survey_participant_list()"},{"location":"api_reference/project/#redcap.project.Project.export_users","text":"Export the users of the Project !!! note Each user will have the following keys: * `'firstname'` : User's first name * `'lastname'` : User's last name * `'email'` : Email address * `'username'` : User's username * `'expiration'` : Project access expiration date * `'data_access_group'` : data access group ID * `'data_export'` : (0=no access, 2=De-Identified, 1=Full Data Set) * `'forms'` : a list of dicts with a single key as the form name and value is an integer describing that user's form rights, where: 0=no access, 1=view records/responses and edit records (survey responses are read-only), 2=read only, and 3=edit survey responses, Parameters: Name Type Description Default format Literal['json', 'csv', 'xml'] Response return format 'json' Returns: Type Description Union[List[Dict], str] List of users with metadata Examples: >>> proj . export_users () [{ 'username' : ... , 'email' : ... , 'expiration' : '' , 'data_access_group' : '' , 'data_access_group_id' : '' , 'design' : 1 , 'user_rights' : 1 , 'data_access_groups' : 1 , 'data_export' : 1 , ... }] Source code in redcap/project.py def export_users ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" ): \"\"\" Export the users of the Project Note: Each user will have the following keys: * `'firstname'` : User's first name * `'lastname'` : User's last name * `'email'` : Email address * `'username'` : User's username * `'expiration'` : Project access expiration date * `'data_access_group'` : data access group ID * `'data_export'` : (0=no access, 2=De-Identified, 1=Full Data Set) * `'forms'` : a list of dicts with a single key as the form name and value is an integer describing that user's form rights, where: 0=no access, 1=view records/responses and edit records (survey responses are read-only), 2=read only, and 3=edit survey responses, Args: format: Response return format Returns: Union[List[Dict], str]: List of users with metadata Examples: >>> proj.export_users() [{'username': ..., 'email': ..., 'expiration': '', 'data_access_group': '', 'data_access_group_id': '', 'design': 1, 'user_rights': 1, 'data_access_groups': 1, 'data_export': 1, ...}] \"\"\" payload = self . _basepl ( content = \"user\" , format = format ) return self . _call_api ( payload , \"exp_user\" )[ 0 ] # pylint: enable=redefined-builtin","title":"export_users()"},{"location":"api_reference/project/#redcap.project.Project.export_version","text":"Get the REDCap version Returns: Type Description Optional[semantic_version.base.Version] REDCap version running on the url provided Examples: >>> import semantic_version >>> redcap_version = proj . export_version () >>> assert redcap_version >= semantic_version . Version ( \"12.0.1\" ) Source code in redcap/project.py def export_version ( self ) -> Optional [ semantic_version . Version ]: \"\"\" Get the REDCap version Returns: REDCap version running on the url provided Examples: >>> import semantic_version >>> redcap_version = proj.export_version() >>> assert redcap_version >= semantic_version.Version(\"12.0.1\") \"\"\" payload = self . _basepl ( \"version\" ) redcap_version = self . _call_api ( payload , \"version\" )[ 0 ] . decode ( \"utf-8\" ) resp : Optional [ semantic_version . Version ] = None if \"error\" in redcap_version : warnings . warn ( \"Version information not available for this REDCap instance\" ) if semantic_version . validate ( redcap_version ): resp = semantic_version . Version ( redcap_version ) return resp","title":"export_version()"},{"location":"api_reference/project/#redcap.project.Project.generate_next_record_name","text":"Get the next record name Returns: Type Description int The next record name for a project with auto-numbering records enabled Examples: >>> proj . generate_next_record_name () 3 Source code in redcap/project.py def generate_next_record_name ( self ) -> int : \"\"\" Get the next record name Returns: The next record name for a project with auto-numbering records enabled Examples: >>> proj.generate_next_record_name() 3 \"\"\" payload = self . _basepl ( content = \"generateNextRecordName\" ) return self . _call_api ( payload , \"exp_next_id\" )[ 0 ]","title":"generate_next_record_name()"},{"location":"api_reference/project/#redcap.project.Project.import_file","text":"Import the contents of a file represented by file_object to a particular records field Parameters: Name Type Description Default record str Record ID required field str Field name where the file will go required file_name str File name visible in REDCap UI required file_object TextIOWrapper File object as returned by open required event Optional[str] For longitudinal projects, the unique event name None repeat_instance Union[int, str] (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). None return_format str 'json' , 'csv' , 'xml' Format of error message 'json' Returns: Type Description Union[Dict, Literal['']] Response from server as specified by return_format Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> import tempfile >>> tmp_file = tempfile . TemporaryFile () >>> proj . import_file ( ... record = \"2\" , ... field = \"upload_field\" , ... file_name = \"myupload.txt\" , ... file_object = tmp_file , ... event = \"event_1_arm_1\" , ... ) {} Source code in redcap/project.py def import_file ( self , record : str , field : str , file_name : str , file_object : \"TextIOWrapper\" , event : Optional [ str ] = None , repeat_instance : Optional [ Union [ int , str ]] = None , return_format : str = \"json\" , ) -> Union [ Dict , Literal [ \"\" ]]: \"\"\" Import the contents of a file represented by file_object to a particular records field Args: record: Record ID field: Field name where the file will go file_name: File name visible in REDCap UI file_object: File object as returned by `open` event: For longitudinal projects, the unique event name repeat_instance: (Only for projects with repeating instruments/events) The repeat instance number of the repeating event (if longitudinal) or the repeating instrument (if classic or longitudinal). return_format: `'json'`, `'csv'`, `'xml'` Format of error message Returns: Response from server as specified by `return_format` Examples: If your project has events, then you must specifiy the event of interest. Otherwise, you can leave the event parameter blank >>> import tempfile >>> tmp_file = tempfile.TemporaryFile() >>> proj.import_file( ... record=\"2\", ... field=\"upload_field\", ... file_name=\"myupload.txt\", ... file_object=tmp_file, ... event=\"event_1_arm_1\", ... ) {} \"\"\" self . _check_file_field ( field ) # load up payload payload = self . _basepl ( content = \"file\" , format = return_format ) # no format in this call del payload [ \"format\" ] payload [ \"returnFormat\" ] = return_format payload [ \"action\" ] = \"import\" payload [ \"field\" ] = field payload [ \"record\" ] = record if event : payload [ \"event\" ] = event if repeat_instance : payload [ \"repeat_instance\" ] = repeat_instance file_kwargs = { \"files\" : { \"file\" : ( file_name , file_object )}} return self . _call_api ( payload , \"imp_file\" , ** file_kwargs )[ 0 ]","title":"import_file()"},{"location":"api_reference/project/#redcap.project.Project.import_metadata","text":"Import metadata (Data Dictionary) into the REDCap Project Parameters: Name Type Description Default to_import Union[str, List[Dict], pd.DataFrame] array of dicts, csv/xml string, pandas.DataFrame Note: If you pass a csv or xml string, you should use the format parameter appropriately. required return_format Literal['json', 'csv', 'xml'] Response format. By default, response will be json-decoded. 'json' format Literal['json', 'csv', 'xml', 'df'] Format of incoming data. By default, to_import will be json-encoded 'json' date_format Literal['YMD', 'DMY', 'MDY'] Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. 'YMD' Returns: Type Description Union[int, str] Response from REDCap API, json-decoded if return_format == 'json' . If successful, the number of imported fields Examples: >>> metadata = proj . export_metadata ( format = \"csv\" ) >>> proj . import_metadata ( metadata , format = \"csv\" ) 4 Source code in redcap/project.py def import_metadata ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , ): \"\"\" Import metadata (Data Dictionary) into the REDCap Project Args: to_import: array of dicts, csv/xml string, `pandas.DataFrame` Note: If you pass a csv or xml string, you should use the `format` parameter appropriately. return_format: Response format. By default, response will be json-decoded. format: Format of incoming data. By default, to_import will be json-encoded date_format: Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. Returns: Union[int, str]: Response from REDCap API, json-decoded if `return_format == 'json'`. If successful, the number of imported fields Examples: >>> metadata = proj.export_metadata(format=\"csv\") >>> proj.import_metadata(metadata, format=\"csv\") 4 \"\"\" payload = self . _initialize_import_payload ( to_import , format , \"metadata\" ) payload [ \"returnFormat\" ] = return_format payload [ \"dateFormat\" ] = date_format response = self . _call_api ( payload , \"imp_metadata\" )[ 0 ] if \"error\" in str ( response ): raise RedcapError ( str ( response )) return response","title":"import_metadata()"},{"location":"api_reference/project/#redcap.project.Project.import_records","text":"Import data into the RedCap Project Parameters: Name Type Description Default to_import Union[str, List[Dict], pd.DataFrame] Note: If you pass a df, csv, or xml string, you should use the format parameter appropriately. Note: Keys of the dictionaries should be subset of project's, fields, but this isn't a requirement. If you provide keys that aren't defined fields, the returned response will contain an 'error' key. required return_format Literal['json', 'csv', 'xml'] Response format. By default, response will be json-decoded. 'json' overwrite Literal['normal', 'overwrite'] 'overwrite' will erase values previously stored in the database if not specified in the to_import dictionaries. 'normal' format Literal['json', 'csv', 'xml', 'df'] Format of incoming data. By default, to_import will be json-encoded 'json' return_content Literal['count', 'ids', 'nothing'] By default, the response contains a 'count' key with the number of records just imported. By specifying 'ids', a list of ids imported will be returned. 'nothing' will only return the HTTP status code and no message. 'count' date_format Literal['YMD', 'DMY', 'MDY'] Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. 'YMD' force_auto_number bool Enables automatic assignment of record IDs of imported records by REDCap. If this is set to true, and auto-numbering for records is enabled for the project, auto-numbering of imported records will be enabled. False Exceptions: Type Description RedcapError Bad request made, double check field names and inputs Returns: Type Description Union[Dict, str] response from REDCap API, json-decoded if return_format == 'json' Examples: >>> new_record = [{ \"record_id\" : 3 , \"field_1\" : 1 }] >>> proj . import_records ( new_record ) { 'count' : 1 } Source code in redcap/project.py def import_records ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" , overwrite : Literal [ \"normal\" , \"overwrite\" ] = \"normal\" , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , return_content : Literal [ \"count\" , \"ids\" , \"nothing\" ] = \"count\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , force_auto_number : bool = False , ): \"\"\" Import data into the RedCap Project Args: to_import: Note: If you pass a df, csv, or xml string, you should use the `format` parameter appropriately. Note: Keys of the dictionaries should be subset of project's, fields, but this isn't a requirement. If you provide keys that aren't defined fields, the returned response will contain an `'error'` key. return_format: Response format. By default, response will be json-decoded. overwrite: `'overwrite'` will erase values previously stored in the database if not specified in the to_import dictionaries. format: Format of incoming data. By default, to_import will be json-encoded return_content: By default, the response contains a 'count' key with the number of records just imported. By specifying 'ids', a list of ids imported will be returned. 'nothing' will only return the HTTP status code and no message. date_format: Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. force_auto_number: Enables automatic assignment of record IDs of imported records by REDCap. If this is set to true, and auto-numbering for records is enabled for the project, auto-numbering of imported records will be enabled. Raises: RedcapError: Bad request made, double check field names and inputs Returns: Union[Dict, str]: response from REDCap API, json-decoded if `return_format` == `'json'` Examples: >>> new_record = [{\"record_id\": 3, \"field_1\": 1}] >>> proj.import_records(new_record) {'count': 1} \"\"\" payload = self . _initialize_import_payload ( to_import , format , \"record\" ) payload [ \"overwriteBehavior\" ] = overwrite payload [ \"returnFormat\" ] = return_format payload [ \"returnContent\" ] = return_content payload [ \"dateFormat\" ] = date_format payload [ \"forceAutoNumber\" ] = force_auto_number response = self . _call_api ( payload , \"imp_record\" )[ 0 ] if \"error\" in response : raise RedcapError ( str ( response )) return response","title":"import_records()"},{"location":"api_reference/project_info/","text":"Project Info REDCap API methods for Project info ProjectInfo ( Base ) Responsible for all API methods under 'Projects' in the API Playground Source code in redcap/methods/project_info.py class ProjectInfo ( Base ): \"\"\"Responsible for all API methods under 'Projects' in the API Playground\"\"\" # pylint: disable=redefined-builtin @overload def export_project_info ( self , format : Literal [ \"json\" ]) -> List [ Dict ]: ... @overload def export_project_info ( self , format : Literal [ \"csv\" , \"xml\" ]) -> str : ... def export_project_info ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" ): \"\"\" Export Project Information Args: format: Format of returned data Returns: Union[str, List[Dict]]: Project information Examples: >>> proj.export_project_info() {'project_id': ... ... 'in_production': 0, 'project_language': 'English', 'purpose': 0, 'purpose_other': '', ... 'project_grant_number': '', 'project_pi_firstname': '', 'project_pi_lastname': '', ... 'bypass_branching_erase_field_prompt': 0} \"\"\" payload = self . _basepl ( content = \"project\" , format = format ) return self . _call_api ( payload , \"exp_proj\" )[ 0 ] # pylint: enable=redefined-builtin def_field : str inherited property readonly The 'record_id' field equivalent for a project events : Optional [ List [ dict ]] inherited property readonly Project defined events !!! note Exists for longitudinal projects only field_names : List [ str ] inherited property readonly Project field names !!! note These are survey field names, not export field names is_longitudinal : bool inherited property readonly Whether or not this project is longitudinal metadata : List [ Dict [ str , str ]] inherited property readonly Project metadata in JSON format token : str inherited property readonly API token to your project url : str inherited property readonly API URL to your REDCap server export_project_info ( self , format = 'json' ) Export Project Information Parameters: Name Type Description Default format Literal['json', 'csv', 'xml'] Format of returned data 'json' Returns: Type Description Union[str, List[Dict]] Project information Examples: >>> proj . export_project_info () { 'project_id' : ... ... 'in_production' : 0 , 'project_language' : 'English' , 'purpose' : 0 , 'purpose_other' : '' , ... 'project_grant_number' : '' , 'project_pi_firstname' : '' , 'project_pi_lastname' : '' , ... 'bypass_branching_erase_field_prompt' : 0 } Source code in redcap/methods/project_info.py def export_project_info ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" ): \"\"\" Export Project Information Args: format: Format of returned data Returns: Union[str, List[Dict]]: Project information Examples: >>> proj.export_project_info() {'project_id': ... ... 'in_production': 0, 'project_language': 'English', 'purpose': 0, 'purpose_other': '', ... 'project_grant_number': '', 'project_pi_firstname': '', 'project_pi_lastname': '', ... 'bypass_branching_erase_field_prompt': 0} \"\"\" payload = self . _basepl ( content = \"project\" , format = format ) return self . _call_api ( payload , \"exp_proj\" )[ 0 ]","title":"Project Info"},{"location":"api_reference/project_info/#project-info","text":"REDCap API methods for Project info","title":"Project Info"},{"location":"api_reference/project_info/#redcap.methods.project_info.ProjectInfo","text":"Responsible for all API methods under 'Projects' in the API Playground Source code in redcap/methods/project_info.py class ProjectInfo ( Base ): \"\"\"Responsible for all API methods under 'Projects' in the API Playground\"\"\" # pylint: disable=redefined-builtin @overload def export_project_info ( self , format : Literal [ \"json\" ]) -> List [ Dict ]: ... @overload def export_project_info ( self , format : Literal [ \"csv\" , \"xml\" ]) -> str : ... def export_project_info ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" ): \"\"\" Export Project Information Args: format: Format of returned data Returns: Union[str, List[Dict]]: Project information Examples: >>> proj.export_project_info() {'project_id': ... ... 'in_production': 0, 'project_language': 'English', 'purpose': 0, 'purpose_other': '', ... 'project_grant_number': '', 'project_pi_firstname': '', 'project_pi_lastname': '', ... 'bypass_branching_erase_field_prompt': 0} \"\"\" payload = self . _basepl ( content = \"project\" , format = format ) return self . _call_api ( payload , \"exp_proj\" )[ 0 ] # pylint: enable=redefined-builtin","title":"ProjectInfo"},{"location":"api_reference/project_info/#redcap.methods.project_info.ProjectInfo.def_field","text":"The 'record_id' field equivalent for a project","title":"def_field"},{"location":"api_reference/project_info/#redcap.methods.project_info.ProjectInfo.events","text":"Project defined events !!! note Exists for longitudinal projects only","title":"events"},{"location":"api_reference/project_info/#redcap.methods.project_info.ProjectInfo.field_names","text":"Project field names !!! note These are survey field names, not export field names","title":"field_names"},{"location":"api_reference/project_info/#redcap.methods.project_info.ProjectInfo.is_longitudinal","text":"Whether or not this project is longitudinal","title":"is_longitudinal"},{"location":"api_reference/project_info/#redcap.methods.project_info.ProjectInfo.metadata","text":"Project metadata in JSON format","title":"metadata"},{"location":"api_reference/project_info/#redcap.methods.project_info.ProjectInfo.token","text":"API token to your project","title":"token"},{"location":"api_reference/project_info/#redcap.methods.project_info.ProjectInfo.url","text":"API URL to your REDCap server","title":"url"},{"location":"api_reference/project_info/#redcap.methods.project_info.ProjectInfo.export_project_info","text":"Export Project Information Parameters: Name Type Description Default format Literal['json', 'csv', 'xml'] Format of returned data 'json' Returns: Type Description Union[str, List[Dict]] Project information Examples: >>> proj . export_project_info () { 'project_id' : ... ... 'in_production' : 0 , 'project_language' : 'English' , 'purpose' : 0 , 'purpose_other' : '' , ... 'project_grant_number' : '' , 'project_pi_firstname' : '' , 'project_pi_lastname' : '' , ... 'bypass_branching_erase_field_prompt' : 0 } Source code in redcap/methods/project_info.py def export_project_info ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" ): \"\"\" Export Project Information Args: format: Format of returned data Returns: Union[str, List[Dict]]: Project information Examples: >>> proj.export_project_info() {'project_id': ... ... 'in_production': 0, 'project_language': 'English', 'purpose': 0, 'purpose_other': '', ... 'project_grant_number': '', 'project_pi_firstname': '', 'project_pi_lastname': '', ... 'bypass_branching_erase_field_prompt': 0} \"\"\" payload = self . _basepl ( content = \"project\" , format = format ) return self . _call_api ( payload , \"exp_proj\" )[ 0 ]","title":"export_project_info()"},{"location":"api_reference/records/","text":"Records REDCap API methods for Project records Records ( Base ) Responsible for all API methods under 'Records' in the API Playground Source code in redcap/methods/records.py class Records ( Base ): \"\"\"Responsible for all API methods under 'Records' in the API Playground\"\"\" # pylint: disable=redefined-builtin # pylint: disable=too-many-branches # pylint: disable=too-many-locals @overload def export_records ( self , format : Literal [ \"json\" ], records : Optional [ List [ str ]] = None , fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , events : Optional [ List [ str ]] = None , raw_or_label : Literal [ \"raw\" , \"label\" , \"both\" ] = \"raw\" , event_name : Literal [ \"label\" , \"unique\" ] = \"label\" , type : Literal [ \"flat\" , \"eav\" ] = \"flat\" , export_survey_fields : bool = False , export_data_access_groups : bool = False , df_kwargs : Optional [ Dict ] = None , export_checkbox_labels : bool = False , filter_logic : Optional [ str ] = None , date_begin : Optional [ datetime ] = None , date_end : Optional [ datetime ] = None , ) -> List [ Dict ]: ... @overload def export_records ( self , format : Literal [ \"csv\" , \"xml\" ], records : Optional [ List [ str ]] = None , fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , events : Optional [ List [ str ]] = None , raw_or_label : Literal [ \"raw\" , \"label\" , \"both\" ] = \"raw\" , event_name : Literal [ \"label\" , \"unique\" ] = \"label\" , type : Literal [ \"flat\" , \"eav\" ] = \"flat\" , export_survey_fields : bool = False , export_data_access_groups : bool = False , df_kwargs : Optional [ Dict ] = None , export_checkbox_labels : bool = False , filter_logic : Optional [ str ] = None , date_begin : Optional [ datetime ] = None , date_end : Optional [ datetime ] = None , ) -> str : ... @overload def export_records ( self , format : Literal [ \"df\" ], records : Optional [ List [ str ]] = None , fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , events : Optional [ List [ str ]] = None , raw_or_label : Literal [ \"raw\" , \"label\" , \"both\" ] = \"raw\" , event_name : Literal [ \"label\" , \"unique\" ] = \"label\" , type : Literal [ \"flat\" , \"eav\" ] = \"flat\" , export_survey_fields : bool = False , export_data_access_groups : bool = False , df_kwargs : Optional [ Dict ] = None , export_checkbox_labels : bool = False , filter_logic : Optional [ str ] = None , date_begin : Optional [ datetime ] = None , date_end : Optional [ datetime ] = None , ) -> \"pd.DataFrame\" : ... def export_records ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , records : Optional [ List [ str ]] = None , fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , events : Optional [ List [ str ]] = None , raw_or_label : Literal [ \"raw\" , \"label\" , \"both\" ] = \"raw\" , event_name : Literal [ \"label\" , \"unique\" ] = \"label\" , type : Literal [ \"flat\" , \"eav\" ] = \"flat\" , export_survey_fields : bool = False , export_data_access_groups : bool = False , df_kwargs : Optional [ Dict ] = None , export_checkbox_labels : bool = False , filter_logic : Optional [ str ] = None , date_begin : Optional [ datetime ] = None , date_end : Optional [ datetime ] = None , ): \"\"\" Export data from the REDCap project. Args: format: Format of returned data. `'json'` returns json-decoded objects while `'csv'` and `'xml'` return other formats. `'df'` will attempt to return a `pandas.DataFrame` records: Array of record names specifying specific records to export. By default, all records are exported fields: Array of field names specifying specific fields to pull by default, all fields are exported forms: Array of form names to export. If in the web UI, the form name has a space in it, replace the space with an underscore By default, all forms are exported events: An array of unique event names from which to export records Note: This only applies to longitudinal projects raw_or_label: Export the raw coded values or labels for the options of multiple choice fields, or both event_name: Export the unique event name or the event label type: Database output structure type export_survey_fields: Specifies whether or not to export the survey identifier field (e.g., \"redcap_survey_identifier\") or survey timestamp fields (e.g., form_name+\"_timestamp\") when surveys are utilized in the project export_data_access_groups: Specifies whether or not to export the `\"redcap_data_access_group\"` field when data access groups are utilized in the project Note: This flag is only viable if the user whose token is being used to make the API request is *not* in a data access group. If the user is in a group, then this flag will revert to its default value. df_kwargs: Passed to `pandas.read_csv` to control construction of returned DataFrame. By default, `{'index_col': self.def_field}` export_checkbox_labels: Specify whether to export checkbox values as their label on export. filter_logic: Filter which records are returned using REDCap conditional syntax date_begin: Filter on records created after a date date_end: Filter on records created before a date Returns: Union[List[Dict], str, pd.DataFrame]: Exported data Examples: >>> proj.export_records() [{'record_id': '1', 'redcap_event_name': 'event_1_arm_1', 'field_1': '1', 'checkbox_field___1': '0', 'checkbox_field___2': '1', 'upload_field': 'test_upload.txt', 'form_1_complete': '2'}, {'record_id': '2', 'redcap_event_name': 'event_1_arm_1', 'field_1': '0', 'checkbox_field___1': '0', 'checkbox_field___2': '0', 'upload_field': 'myupload.txt', 'form_1_complete': '0'}] >>> proj.export_records(filter_logic=\"[field_1] = 1\") [{'record_id': '1', 'redcap_event_name': 'event_1_arm_1', 'field_1': '1', 'checkbox_field___1': '0', 'checkbox_field___2': '1', 'upload_field': 'test_upload.txt', 'form_1_complete': '2'}] >>> proj.export_records( ... format=\"csv\", ... fields=[\"field_1\", \"checkbox_field\"], ... raw_or_label=\"label\" ... ) 'field_1,checkbox_field___1,checkbox_field___2\\\\nYes,Unchecked,Checked\\\\nNo,Unchecked,Unchecked\\\\n' >>> import pandas as pd >>> pd.set_option(\"display.max_columns\", 3) >>> proj.export_records(format=\"df\") field_1 ... form_1_complete record_id redcap_event_name ... 1 event_1_arm_1 1 ... 2 2 event_1_arm_1 0 ... 0 ... \"\"\" # pylint: disable=line-too-long # pylint: enable=line-too-long ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"record\" , format = ret_format , rec_type = type ) keys_to_add = ( records , fields , forms , events , raw_or_label , event_name , export_survey_fields , export_data_access_groups , export_checkbox_labels , ) str_keys = ( \"records\" , \"fields\" , \"forms\" , \"events\" , \"rawOrLabel\" , \"eventName\" , \"exportSurveyFields\" , \"exportDataAccessGroups\" , \"exportCheckboxLabel\" , ) for key , data in zip ( str_keys , keys_to_add ): if data : if key in ( \"fields\" , \"records\" , \"forms\" , \"events\" ): for i , value in enumerate ( data ): payload [ f \" { key } [ { i } ]\" ] = value else : payload [ key ] = data if date_begin : payload [ \"dateRangeBegin\" ] = date_begin . strftime ( \"%Y-%m- %d %H:%M:%S\" ) if date_end : payload [ \"dateRangeEnd\" ] = date_end . strftime ( \"%Y-%m- %d %H:%M:%S\" ) if filter_logic : payload [ \"filterLogic\" ] = filter_logic response , _ = self . _call_api ( payload , \"exp_record\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : if type == \"eav\" : df_kwargs = {} else : if self . is_longitudinal : df_kwargs = { \"index_col\" : [ self . def_field , \"redcap_event_name\" ]} else : df_kwargs = { \"index_col\" : self . def_field } buf = StringIO ( response ) dataframe = self . _read_csv ( buf , ** df_kwargs ) buf . close () return dataframe # pylint: enable=too-many-branches # pylint: enable=too-many-locals @overload def import_records ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"json\" ], overwrite : Literal [ \"normal\" , \"overwrite\" ] = \"normal\" , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , return_content : Literal [ \"count\" , \"ids\" , \"nothing\" ] = \"count\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , force_auto_number : bool = False , ) -> Dict : ... @overload def import_records ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"csv\" , \"xml\" ], overwrite : Literal [ \"normal\" , \"overwrite\" ] = \"normal\" , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , return_content : Literal [ \"count\" , \"ids\" , \"nothing\" ] = \"count\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , force_auto_number : bool = False , ) -> str : ... def import_records ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" , overwrite : Literal [ \"normal\" , \"overwrite\" ] = \"normal\" , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , return_content : Literal [ \"count\" , \"ids\" , \"nothing\" ] = \"count\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , force_auto_number : bool = False , ): \"\"\" Import data into the RedCap Project Args: to_import: Note: If you pass a df, csv, or xml string, you should use the `format` parameter appropriately. Note: Keys of the dictionaries should be subset of project's, fields, but this isn't a requirement. If you provide keys that aren't defined fields, the returned response will contain an `'error'` key. return_format: Response format. By default, response will be json-decoded. overwrite: `'overwrite'` will erase values previously stored in the database if not specified in the to_import dictionaries. format: Format of incoming data. By default, to_import will be json-encoded return_content: By default, the response contains a 'count' key with the number of records just imported. By specifying 'ids', a list of ids imported will be returned. 'nothing' will only return the HTTP status code and no message. date_format: Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. force_auto_number: Enables automatic assignment of record IDs of imported records by REDCap. If this is set to true, and auto-numbering for records is enabled for the project, auto-numbering of imported records will be enabled. Raises: RedcapError: Bad request made, double check field names and inputs Returns: Union[Dict, str]: response from REDCap API, json-decoded if `return_format` == `'json'` Examples: >>> new_record = [{\"record_id\": 3, \"field_1\": 1}] >>> proj.import_records(new_record) {'count': 1} \"\"\" payload = self . _initialize_import_payload ( to_import , format , \"record\" ) payload [ \"overwriteBehavior\" ] = overwrite payload [ \"returnFormat\" ] = return_format payload [ \"returnContent\" ] = return_content payload [ \"dateFormat\" ] = date_format payload [ \"forceAutoNumber\" ] = force_auto_number response = self . _call_api ( payload , \"imp_record\" )[ 0 ] if \"error\" in response : raise RedcapError ( str ( response )) return response def delete_records ( self , records : List [ str ]) -> int : \"\"\" Delete records from the project. Args: records: List of record IDs to delete from the project Returns: Number of records deleted Examples: >>> new_record = [{\"record_id\": 3, \"field_1\": 1}, {\"record_id\": 4}] >>> proj.import_records(new_record) {'count': 2} >>> proj.delete_records([\"3\", \"4\"]) '2' \"\"\" payload = {} payload [ \"action\" ] = \"delete\" payload [ \"content\" ] = \"record\" payload [ \"token\" ] = self . token # Turn list of records into dict, and append to payload records_dict = { f \"records[ { idx } ]\" : record for idx , record in enumerate ( records ) } payload . update ( records_dict ) payload [ \"format\" ] = format response , _ = self . _call_api ( payload , \"del_record\" ) return response # pylint: disable=redefined-builtin def generate_next_record_name ( self ) -> int : \"\"\" Get the next record name Returns: The next record name for a project with auto-numbering records enabled Examples: >>> proj.generate_next_record_name() 3 \"\"\" payload = self . _basepl ( content = \"generateNextRecordName\" ) return self . _call_api ( payload , \"exp_next_id\" )[ 0 ] def_field : str inherited property readonly The 'record_id' field equivalent for a project events : Optional [ List [ dict ]] inherited property readonly Project defined events !!! note Exists for longitudinal projects only field_names : List [ str ] inherited property readonly Project field names !!! note These are survey field names, not export field names is_longitudinal : bool inherited property readonly Whether or not this project is longitudinal metadata : List [ Dict [ str , str ]] inherited property readonly Project metadata in JSON format token : str inherited property readonly API token to your project url : str inherited property readonly API URL to your REDCap server delete_records ( self , records ) Delete records from the project. Parameters: Name Type Description Default records List[str] List of record IDs to delete from the project required Returns: Type Description int Number of records deleted Examples: >>> new_record = [{ \"record_id\" : 3 , \"field_1\" : 1 }, { \"record_id\" : 4 }] >>> proj . import_records ( new_record ) { 'count' : 2 } >>> proj . delete_records ([ \"3\" , \"4\" ]) '2' Source code in redcap/methods/records.py def delete_records ( self , records : List [ str ]) -> int : \"\"\" Delete records from the project. Args: records: List of record IDs to delete from the project Returns: Number of records deleted Examples: >>> new_record = [{\"record_id\": 3, \"field_1\": 1}, {\"record_id\": 4}] >>> proj.import_records(new_record) {'count': 2} >>> proj.delete_records([\"3\", \"4\"]) '2' \"\"\" payload = {} payload [ \"action\" ] = \"delete\" payload [ \"content\" ] = \"record\" payload [ \"token\" ] = self . token # Turn list of records into dict, and append to payload records_dict = { f \"records[ { idx } ]\" : record for idx , record in enumerate ( records ) } payload . update ( records_dict ) payload [ \"format\" ] = format response , _ = self . _call_api ( payload , \"del_record\" ) return response # pylint: disable=redefined-builtin export_records ( self , format = 'json' , records = None , fields = None , forms = None , events = None , raw_or_label = 'raw' , event_name = 'label' , type = 'flat' , export_survey_fields = False , export_data_access_groups = False , df_kwargs = None , export_checkbox_labels = False , filter_logic = None , date_begin = None , date_end = None ) Export data from the REDCap project. Parameters: Name Type Description Default format Literal['json', 'csv', 'xml', 'df'] Format of returned data. 'json' returns json-decoded objects while 'csv' and 'xml' return other formats. 'df' will attempt to return a pandas.DataFrame 'json' records Optional[List[str]] Array of record names specifying specific records to export. By default, all records are exported None fields Optional[List[str]] Array of field names specifying specific fields to pull by default, all fields are exported None forms Optional[List[str]] Array of form names to export. If in the web UI, the form name has a space in it, replace the space with an underscore By default, all forms are exported None events Optional[List[str]] An array of unique event names from which to export records Note: This only applies to longitudinal projects None raw_or_label Literal['raw', 'label', 'both'] Export the raw coded values or labels for the options of multiple choice fields, or both 'raw' event_name Literal['label', 'unique'] Export the unique event name or the event label 'label' type Literal['flat', 'eav'] Database output structure type 'flat' export_survey_fields bool Specifies whether or not to export the survey identifier field (e.g., \"redcap_survey_identifier\") or survey timestamp fields (e.g., form_name+\"_timestamp\") when surveys are utilized in the project False export_data_access_groups bool Specifies whether or not to export the \"redcap_data_access_group\" field when data access groups are utilized in the project Note: This flag is only viable if the user whose token is being used to make the API request is not in a data access group. If the user is in a group, then this flag will revert to its default value. False df_kwargs Optional[Dict] Passed to pandas.read_csv to control construction of returned DataFrame. By default, {'index_col': self.def_field} None export_checkbox_labels bool Specify whether to export checkbox values as their label on export. False filter_logic Optional[str] Filter which records are returned using REDCap conditional syntax None date_begin Optional[datetime.datetime] Filter on records created after a date None date_end Optional[datetime.datetime] Filter on records created before a date None Returns: Type Description Union[List[Dict], str, pd.DataFrame] Exported data Examples: >>> proj . export_records () [{ 'record_id' : '1' , 'redcap_event_name' : 'event_1_arm_1' , 'field_1' : '1' , 'checkbox_field___1' : '0' , 'checkbox_field___2' : '1' , 'upload_field' : 'test_upload.txt' , 'form_1_complete' : '2' }, { 'record_id' : '2' , 'redcap_event_name' : 'event_1_arm_1' , 'field_1' : '0' , 'checkbox_field___1' : '0' , 'checkbox_field___2' : '0' , 'upload_field' : 'myupload.txt' , 'form_1_complete' : '0' }] >>> proj . export_records ( filter_logic = \"[field_1] = 1\" ) [{ 'record_id' : '1' , 'redcap_event_name' : 'event_1_arm_1' , 'field_1' : '1' , 'checkbox_field___1' : '0' , 'checkbox_field___2' : '1' , 'upload_field' : 'test_upload.txt' , 'form_1_complete' : '2' }] >>> proj . export_records ( ... format = \"csv\" , ... fields = [ \"field_1\" , \"checkbox_field\" ], ... raw_or_label = \"label\" ... ) 'field_1,checkbox_field___1,checkbox_field___2 \\n Yes,Unchecked,Checked \\n No,Unchecked,Unchecked \\n ' >>> import pandas as pd >>> pd . set_option ( \"display.max_columns\" , 3 ) >>> proj . export_records ( format = \"df\" ) field_1 ... form_1_complete record_id redcap_event_name ... 1 event_1_arm_1 1 ... 2 2 event_1_arm_1 0 ... 0 ... Source code in redcap/methods/records.py def export_records ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , records : Optional [ List [ str ]] = None , fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , events : Optional [ List [ str ]] = None , raw_or_label : Literal [ \"raw\" , \"label\" , \"both\" ] = \"raw\" , event_name : Literal [ \"label\" , \"unique\" ] = \"label\" , type : Literal [ \"flat\" , \"eav\" ] = \"flat\" , export_survey_fields : bool = False , export_data_access_groups : bool = False , df_kwargs : Optional [ Dict ] = None , export_checkbox_labels : bool = False , filter_logic : Optional [ str ] = None , date_begin : Optional [ datetime ] = None , date_end : Optional [ datetime ] = None , ): \"\"\" Export data from the REDCap project. Args: format: Format of returned data. `'json'` returns json-decoded objects while `'csv'` and `'xml'` return other formats. `'df'` will attempt to return a `pandas.DataFrame` records: Array of record names specifying specific records to export. By default, all records are exported fields: Array of field names specifying specific fields to pull by default, all fields are exported forms: Array of form names to export. If in the web UI, the form name has a space in it, replace the space with an underscore By default, all forms are exported events: An array of unique event names from which to export records Note: This only applies to longitudinal projects raw_or_label: Export the raw coded values or labels for the options of multiple choice fields, or both event_name: Export the unique event name or the event label type: Database output structure type export_survey_fields: Specifies whether or not to export the survey identifier field (e.g., \"redcap_survey_identifier\") or survey timestamp fields (e.g., form_name+\"_timestamp\") when surveys are utilized in the project export_data_access_groups: Specifies whether or not to export the `\"redcap_data_access_group\"` field when data access groups are utilized in the project Note: This flag is only viable if the user whose token is being used to make the API request is *not* in a data access group. If the user is in a group, then this flag will revert to its default value. df_kwargs: Passed to `pandas.read_csv` to control construction of returned DataFrame. By default, `{'index_col': self.def_field}` export_checkbox_labels: Specify whether to export checkbox values as their label on export. filter_logic: Filter which records are returned using REDCap conditional syntax date_begin: Filter on records created after a date date_end: Filter on records created before a date Returns: Union[List[Dict], str, pd.DataFrame]: Exported data Examples: >>> proj.export_records() [{'record_id': '1', 'redcap_event_name': 'event_1_arm_1', 'field_1': '1', 'checkbox_field___1': '0', 'checkbox_field___2': '1', 'upload_field': 'test_upload.txt', 'form_1_complete': '2'}, {'record_id': '2', 'redcap_event_name': 'event_1_arm_1', 'field_1': '0', 'checkbox_field___1': '0', 'checkbox_field___2': '0', 'upload_field': 'myupload.txt', 'form_1_complete': '0'}] >>> proj.export_records(filter_logic=\"[field_1] = 1\") [{'record_id': '1', 'redcap_event_name': 'event_1_arm_1', 'field_1': '1', 'checkbox_field___1': '0', 'checkbox_field___2': '1', 'upload_field': 'test_upload.txt', 'form_1_complete': '2'}] >>> proj.export_records( ... format=\"csv\", ... fields=[\"field_1\", \"checkbox_field\"], ... raw_or_label=\"label\" ... ) 'field_1,checkbox_field___1,checkbox_field___2\\\\nYes,Unchecked,Checked\\\\nNo,Unchecked,Unchecked\\\\n' >>> import pandas as pd >>> pd.set_option(\"display.max_columns\", 3) >>> proj.export_records(format=\"df\") field_1 ... form_1_complete record_id redcap_event_name ... 1 event_1_arm_1 1 ... 2 2 event_1_arm_1 0 ... 0 ... \"\"\" # pylint: disable=line-too-long # pylint: enable=line-too-long ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"record\" , format = ret_format , rec_type = type ) keys_to_add = ( records , fields , forms , events , raw_or_label , event_name , export_survey_fields , export_data_access_groups , export_checkbox_labels , ) str_keys = ( \"records\" , \"fields\" , \"forms\" , \"events\" , \"rawOrLabel\" , \"eventName\" , \"exportSurveyFields\" , \"exportDataAccessGroups\" , \"exportCheckboxLabel\" , ) for key , data in zip ( str_keys , keys_to_add ): if data : if key in ( \"fields\" , \"records\" , \"forms\" , \"events\" ): for i , value in enumerate ( data ): payload [ f \" { key } [ { i } ]\" ] = value else : payload [ key ] = data if date_begin : payload [ \"dateRangeBegin\" ] = date_begin . strftime ( \"%Y-%m- %d %H:%M:%S\" ) if date_end : payload [ \"dateRangeEnd\" ] = date_end . strftime ( \"%Y-%m- %d %H:%M:%S\" ) if filter_logic : payload [ \"filterLogic\" ] = filter_logic response , _ = self . _call_api ( payload , \"exp_record\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : if type == \"eav\" : df_kwargs = {} else : if self . is_longitudinal : df_kwargs = { \"index_col\" : [ self . def_field , \"redcap_event_name\" ]} else : df_kwargs = { \"index_col\" : self . def_field } buf = StringIO ( response ) dataframe = self . _read_csv ( buf , ** df_kwargs ) buf . close () return dataframe generate_next_record_name ( self ) Get the next record name Returns: Type Description int The next record name for a project with auto-numbering records enabled Examples: >>> proj . generate_next_record_name () 3 Source code in redcap/methods/records.py def generate_next_record_name ( self ) -> int : \"\"\" Get the next record name Returns: The next record name for a project with auto-numbering records enabled Examples: >>> proj.generate_next_record_name() 3 \"\"\" payload = self . _basepl ( content = \"generateNextRecordName\" ) return self . _call_api ( payload , \"exp_next_id\" )[ 0 ] import_records ( self , to_import , return_format = 'json' , overwrite = 'normal' , format = 'json' , return_content = 'count' , date_format = 'YMD' , force_auto_number = False ) Import data into the RedCap Project Parameters: Name Type Description Default to_import Union[str, List[Dict], pd.DataFrame] Note: If you pass a df, csv, or xml string, you should use the format parameter appropriately. Note: Keys of the dictionaries should be subset of project's, fields, but this isn't a requirement. If you provide keys that aren't defined fields, the returned response will contain an 'error' key. required return_format Literal['json', 'csv', 'xml'] Response format. By default, response will be json-decoded. 'json' overwrite Literal['normal', 'overwrite'] 'overwrite' will erase values previously stored in the database if not specified in the to_import dictionaries. 'normal' format Literal['json', 'csv', 'xml', 'df'] Format of incoming data. By default, to_import will be json-encoded 'json' return_content Literal['count', 'ids', 'nothing'] By default, the response contains a 'count' key with the number of records just imported. By specifying 'ids', a list of ids imported will be returned. 'nothing' will only return the HTTP status code and no message. 'count' date_format Literal['YMD', 'DMY', 'MDY'] Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. 'YMD' force_auto_number bool Enables automatic assignment of record IDs of imported records by REDCap. If this is set to true, and auto-numbering for records is enabled for the project, auto-numbering of imported records will be enabled. False Exceptions: Type Description RedcapError Bad request made, double check field names and inputs Returns: Type Description Union[Dict, str] response from REDCap API, json-decoded if return_format == 'json' Examples: >>> new_record = [{ \"record_id\" : 3 , \"field_1\" : 1 }] >>> proj . import_records ( new_record ) { 'count' : 1 } Source code in redcap/methods/records.py def import_records ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" , overwrite : Literal [ \"normal\" , \"overwrite\" ] = \"normal\" , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , return_content : Literal [ \"count\" , \"ids\" , \"nothing\" ] = \"count\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , force_auto_number : bool = False , ): \"\"\" Import data into the RedCap Project Args: to_import: Note: If you pass a df, csv, or xml string, you should use the `format` parameter appropriately. Note: Keys of the dictionaries should be subset of project's, fields, but this isn't a requirement. If you provide keys that aren't defined fields, the returned response will contain an `'error'` key. return_format: Response format. By default, response will be json-decoded. overwrite: `'overwrite'` will erase values previously stored in the database if not specified in the to_import dictionaries. format: Format of incoming data. By default, to_import will be json-encoded return_content: By default, the response contains a 'count' key with the number of records just imported. By specifying 'ids', a list of ids imported will be returned. 'nothing' will only return the HTTP status code and no message. date_format: Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. force_auto_number: Enables automatic assignment of record IDs of imported records by REDCap. If this is set to true, and auto-numbering for records is enabled for the project, auto-numbering of imported records will be enabled. Raises: RedcapError: Bad request made, double check field names and inputs Returns: Union[Dict, str]: response from REDCap API, json-decoded if `return_format` == `'json'` Examples: >>> new_record = [{\"record_id\": 3, \"field_1\": 1}] >>> proj.import_records(new_record) {'count': 1} \"\"\" payload = self . _initialize_import_payload ( to_import , format , \"record\" ) payload [ \"overwriteBehavior\" ] = overwrite payload [ \"returnFormat\" ] = return_format payload [ \"returnContent\" ] = return_content payload [ \"dateFormat\" ] = date_format payload [ \"forceAutoNumber\" ] = force_auto_number response = self . _call_api ( payload , \"imp_record\" )[ 0 ] if \"error\" in response : raise RedcapError ( str ( response )) return response","title":"Records"},{"location":"api_reference/records/#records","text":"REDCap API methods for Project records","title":"Records"},{"location":"api_reference/records/#redcap.methods.records.Records","text":"Responsible for all API methods under 'Records' in the API Playground Source code in redcap/methods/records.py class Records ( Base ): \"\"\"Responsible for all API methods under 'Records' in the API Playground\"\"\" # pylint: disable=redefined-builtin # pylint: disable=too-many-branches # pylint: disable=too-many-locals @overload def export_records ( self , format : Literal [ \"json\" ], records : Optional [ List [ str ]] = None , fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , events : Optional [ List [ str ]] = None , raw_or_label : Literal [ \"raw\" , \"label\" , \"both\" ] = \"raw\" , event_name : Literal [ \"label\" , \"unique\" ] = \"label\" , type : Literal [ \"flat\" , \"eav\" ] = \"flat\" , export_survey_fields : bool = False , export_data_access_groups : bool = False , df_kwargs : Optional [ Dict ] = None , export_checkbox_labels : bool = False , filter_logic : Optional [ str ] = None , date_begin : Optional [ datetime ] = None , date_end : Optional [ datetime ] = None , ) -> List [ Dict ]: ... @overload def export_records ( self , format : Literal [ \"csv\" , \"xml\" ], records : Optional [ List [ str ]] = None , fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , events : Optional [ List [ str ]] = None , raw_or_label : Literal [ \"raw\" , \"label\" , \"both\" ] = \"raw\" , event_name : Literal [ \"label\" , \"unique\" ] = \"label\" , type : Literal [ \"flat\" , \"eav\" ] = \"flat\" , export_survey_fields : bool = False , export_data_access_groups : bool = False , df_kwargs : Optional [ Dict ] = None , export_checkbox_labels : bool = False , filter_logic : Optional [ str ] = None , date_begin : Optional [ datetime ] = None , date_end : Optional [ datetime ] = None , ) -> str : ... @overload def export_records ( self , format : Literal [ \"df\" ], records : Optional [ List [ str ]] = None , fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , events : Optional [ List [ str ]] = None , raw_or_label : Literal [ \"raw\" , \"label\" , \"both\" ] = \"raw\" , event_name : Literal [ \"label\" , \"unique\" ] = \"label\" , type : Literal [ \"flat\" , \"eav\" ] = \"flat\" , export_survey_fields : bool = False , export_data_access_groups : bool = False , df_kwargs : Optional [ Dict ] = None , export_checkbox_labels : bool = False , filter_logic : Optional [ str ] = None , date_begin : Optional [ datetime ] = None , date_end : Optional [ datetime ] = None , ) -> \"pd.DataFrame\" : ... def export_records ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , records : Optional [ List [ str ]] = None , fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , events : Optional [ List [ str ]] = None , raw_or_label : Literal [ \"raw\" , \"label\" , \"both\" ] = \"raw\" , event_name : Literal [ \"label\" , \"unique\" ] = \"label\" , type : Literal [ \"flat\" , \"eav\" ] = \"flat\" , export_survey_fields : bool = False , export_data_access_groups : bool = False , df_kwargs : Optional [ Dict ] = None , export_checkbox_labels : bool = False , filter_logic : Optional [ str ] = None , date_begin : Optional [ datetime ] = None , date_end : Optional [ datetime ] = None , ): \"\"\" Export data from the REDCap project. Args: format: Format of returned data. `'json'` returns json-decoded objects while `'csv'` and `'xml'` return other formats. `'df'` will attempt to return a `pandas.DataFrame` records: Array of record names specifying specific records to export. By default, all records are exported fields: Array of field names specifying specific fields to pull by default, all fields are exported forms: Array of form names to export. If in the web UI, the form name has a space in it, replace the space with an underscore By default, all forms are exported events: An array of unique event names from which to export records Note: This only applies to longitudinal projects raw_or_label: Export the raw coded values or labels for the options of multiple choice fields, or both event_name: Export the unique event name or the event label type: Database output structure type export_survey_fields: Specifies whether or not to export the survey identifier field (e.g., \"redcap_survey_identifier\") or survey timestamp fields (e.g., form_name+\"_timestamp\") when surveys are utilized in the project export_data_access_groups: Specifies whether or not to export the `\"redcap_data_access_group\"` field when data access groups are utilized in the project Note: This flag is only viable if the user whose token is being used to make the API request is *not* in a data access group. If the user is in a group, then this flag will revert to its default value. df_kwargs: Passed to `pandas.read_csv` to control construction of returned DataFrame. By default, `{'index_col': self.def_field}` export_checkbox_labels: Specify whether to export checkbox values as their label on export. filter_logic: Filter which records are returned using REDCap conditional syntax date_begin: Filter on records created after a date date_end: Filter on records created before a date Returns: Union[List[Dict], str, pd.DataFrame]: Exported data Examples: >>> proj.export_records() [{'record_id': '1', 'redcap_event_name': 'event_1_arm_1', 'field_1': '1', 'checkbox_field___1': '0', 'checkbox_field___2': '1', 'upload_field': 'test_upload.txt', 'form_1_complete': '2'}, {'record_id': '2', 'redcap_event_name': 'event_1_arm_1', 'field_1': '0', 'checkbox_field___1': '0', 'checkbox_field___2': '0', 'upload_field': 'myupload.txt', 'form_1_complete': '0'}] >>> proj.export_records(filter_logic=\"[field_1] = 1\") [{'record_id': '1', 'redcap_event_name': 'event_1_arm_1', 'field_1': '1', 'checkbox_field___1': '0', 'checkbox_field___2': '1', 'upload_field': 'test_upload.txt', 'form_1_complete': '2'}] >>> proj.export_records( ... format=\"csv\", ... fields=[\"field_1\", \"checkbox_field\"], ... raw_or_label=\"label\" ... ) 'field_1,checkbox_field___1,checkbox_field___2\\\\nYes,Unchecked,Checked\\\\nNo,Unchecked,Unchecked\\\\n' >>> import pandas as pd >>> pd.set_option(\"display.max_columns\", 3) >>> proj.export_records(format=\"df\") field_1 ... form_1_complete record_id redcap_event_name ... 1 event_1_arm_1 1 ... 2 2 event_1_arm_1 0 ... 0 ... \"\"\" # pylint: disable=line-too-long # pylint: enable=line-too-long ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"record\" , format = ret_format , rec_type = type ) keys_to_add = ( records , fields , forms , events , raw_or_label , event_name , export_survey_fields , export_data_access_groups , export_checkbox_labels , ) str_keys = ( \"records\" , \"fields\" , \"forms\" , \"events\" , \"rawOrLabel\" , \"eventName\" , \"exportSurveyFields\" , \"exportDataAccessGroups\" , \"exportCheckboxLabel\" , ) for key , data in zip ( str_keys , keys_to_add ): if data : if key in ( \"fields\" , \"records\" , \"forms\" , \"events\" ): for i , value in enumerate ( data ): payload [ f \" { key } [ { i } ]\" ] = value else : payload [ key ] = data if date_begin : payload [ \"dateRangeBegin\" ] = date_begin . strftime ( \"%Y-%m- %d %H:%M:%S\" ) if date_end : payload [ \"dateRangeEnd\" ] = date_end . strftime ( \"%Y-%m- %d %H:%M:%S\" ) if filter_logic : payload [ \"filterLogic\" ] = filter_logic response , _ = self . _call_api ( payload , \"exp_record\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : if type == \"eav\" : df_kwargs = {} else : if self . is_longitudinal : df_kwargs = { \"index_col\" : [ self . def_field , \"redcap_event_name\" ]} else : df_kwargs = { \"index_col\" : self . def_field } buf = StringIO ( response ) dataframe = self . _read_csv ( buf , ** df_kwargs ) buf . close () return dataframe # pylint: enable=too-many-branches # pylint: enable=too-many-locals @overload def import_records ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"json\" ], overwrite : Literal [ \"normal\" , \"overwrite\" ] = \"normal\" , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , return_content : Literal [ \"count\" , \"ids\" , \"nothing\" ] = \"count\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , force_auto_number : bool = False , ) -> Dict : ... @overload def import_records ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"csv\" , \"xml\" ], overwrite : Literal [ \"normal\" , \"overwrite\" ] = \"normal\" , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , return_content : Literal [ \"count\" , \"ids\" , \"nothing\" ] = \"count\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , force_auto_number : bool = False , ) -> str : ... def import_records ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" , overwrite : Literal [ \"normal\" , \"overwrite\" ] = \"normal\" , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , return_content : Literal [ \"count\" , \"ids\" , \"nothing\" ] = \"count\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , force_auto_number : bool = False , ): \"\"\" Import data into the RedCap Project Args: to_import: Note: If you pass a df, csv, or xml string, you should use the `format` parameter appropriately. Note: Keys of the dictionaries should be subset of project's, fields, but this isn't a requirement. If you provide keys that aren't defined fields, the returned response will contain an `'error'` key. return_format: Response format. By default, response will be json-decoded. overwrite: `'overwrite'` will erase values previously stored in the database if not specified in the to_import dictionaries. format: Format of incoming data. By default, to_import will be json-encoded return_content: By default, the response contains a 'count' key with the number of records just imported. By specifying 'ids', a list of ids imported will be returned. 'nothing' will only return the HTTP status code and no message. date_format: Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. force_auto_number: Enables automatic assignment of record IDs of imported records by REDCap. If this is set to true, and auto-numbering for records is enabled for the project, auto-numbering of imported records will be enabled. Raises: RedcapError: Bad request made, double check field names and inputs Returns: Union[Dict, str]: response from REDCap API, json-decoded if `return_format` == `'json'` Examples: >>> new_record = [{\"record_id\": 3, \"field_1\": 1}] >>> proj.import_records(new_record) {'count': 1} \"\"\" payload = self . _initialize_import_payload ( to_import , format , \"record\" ) payload [ \"overwriteBehavior\" ] = overwrite payload [ \"returnFormat\" ] = return_format payload [ \"returnContent\" ] = return_content payload [ \"dateFormat\" ] = date_format payload [ \"forceAutoNumber\" ] = force_auto_number response = self . _call_api ( payload , \"imp_record\" )[ 0 ] if \"error\" in response : raise RedcapError ( str ( response )) return response def delete_records ( self , records : List [ str ]) -> int : \"\"\" Delete records from the project. Args: records: List of record IDs to delete from the project Returns: Number of records deleted Examples: >>> new_record = [{\"record_id\": 3, \"field_1\": 1}, {\"record_id\": 4}] >>> proj.import_records(new_record) {'count': 2} >>> proj.delete_records([\"3\", \"4\"]) '2' \"\"\" payload = {} payload [ \"action\" ] = \"delete\" payload [ \"content\" ] = \"record\" payload [ \"token\" ] = self . token # Turn list of records into dict, and append to payload records_dict = { f \"records[ { idx } ]\" : record for idx , record in enumerate ( records ) } payload . update ( records_dict ) payload [ \"format\" ] = format response , _ = self . _call_api ( payload , \"del_record\" ) return response # pylint: disable=redefined-builtin def generate_next_record_name ( self ) -> int : \"\"\" Get the next record name Returns: The next record name for a project with auto-numbering records enabled Examples: >>> proj.generate_next_record_name() 3 \"\"\" payload = self . _basepl ( content = \"generateNextRecordName\" ) return self . _call_api ( payload , \"exp_next_id\" )[ 0 ]","title":"Records"},{"location":"api_reference/records/#redcap.methods.records.Records.def_field","text":"The 'record_id' field equivalent for a project","title":"def_field"},{"location":"api_reference/records/#redcap.methods.records.Records.events","text":"Project defined events !!! note Exists for longitudinal projects only","title":"events"},{"location":"api_reference/records/#redcap.methods.records.Records.field_names","text":"Project field names !!! note These are survey field names, not export field names","title":"field_names"},{"location":"api_reference/records/#redcap.methods.records.Records.is_longitudinal","text":"Whether or not this project is longitudinal","title":"is_longitudinal"},{"location":"api_reference/records/#redcap.methods.records.Records.metadata","text":"Project metadata in JSON format","title":"metadata"},{"location":"api_reference/records/#redcap.methods.records.Records.token","text":"API token to your project","title":"token"},{"location":"api_reference/records/#redcap.methods.records.Records.url","text":"API URL to your REDCap server","title":"url"},{"location":"api_reference/records/#redcap.methods.records.Records.delete_records","text":"Delete records from the project. Parameters: Name Type Description Default records List[str] List of record IDs to delete from the project required Returns: Type Description int Number of records deleted Examples: >>> new_record = [{ \"record_id\" : 3 , \"field_1\" : 1 }, { \"record_id\" : 4 }] >>> proj . import_records ( new_record ) { 'count' : 2 } >>> proj . delete_records ([ \"3\" , \"4\" ]) '2' Source code in redcap/methods/records.py def delete_records ( self , records : List [ str ]) -> int : \"\"\" Delete records from the project. Args: records: List of record IDs to delete from the project Returns: Number of records deleted Examples: >>> new_record = [{\"record_id\": 3, \"field_1\": 1}, {\"record_id\": 4}] >>> proj.import_records(new_record) {'count': 2} >>> proj.delete_records([\"3\", \"4\"]) '2' \"\"\" payload = {} payload [ \"action\" ] = \"delete\" payload [ \"content\" ] = \"record\" payload [ \"token\" ] = self . token # Turn list of records into dict, and append to payload records_dict = { f \"records[ { idx } ]\" : record for idx , record in enumerate ( records ) } payload . update ( records_dict ) payload [ \"format\" ] = format response , _ = self . _call_api ( payload , \"del_record\" ) return response # pylint: disable=redefined-builtin","title":"delete_records()"},{"location":"api_reference/records/#redcap.methods.records.Records.export_records","text":"Export data from the REDCap project. Parameters: Name Type Description Default format Literal['json', 'csv', 'xml', 'df'] Format of returned data. 'json' returns json-decoded objects while 'csv' and 'xml' return other formats. 'df' will attempt to return a pandas.DataFrame 'json' records Optional[List[str]] Array of record names specifying specific records to export. By default, all records are exported None fields Optional[List[str]] Array of field names specifying specific fields to pull by default, all fields are exported None forms Optional[List[str]] Array of form names to export. If in the web UI, the form name has a space in it, replace the space with an underscore By default, all forms are exported None events Optional[List[str]] An array of unique event names from which to export records Note: This only applies to longitudinal projects None raw_or_label Literal['raw', 'label', 'both'] Export the raw coded values or labels for the options of multiple choice fields, or both 'raw' event_name Literal['label', 'unique'] Export the unique event name or the event label 'label' type Literal['flat', 'eav'] Database output structure type 'flat' export_survey_fields bool Specifies whether or not to export the survey identifier field (e.g., \"redcap_survey_identifier\") or survey timestamp fields (e.g., form_name+\"_timestamp\") when surveys are utilized in the project False export_data_access_groups bool Specifies whether or not to export the \"redcap_data_access_group\" field when data access groups are utilized in the project Note: This flag is only viable if the user whose token is being used to make the API request is not in a data access group. If the user is in a group, then this flag will revert to its default value. False df_kwargs Optional[Dict] Passed to pandas.read_csv to control construction of returned DataFrame. By default, {'index_col': self.def_field} None export_checkbox_labels bool Specify whether to export checkbox values as their label on export. False filter_logic Optional[str] Filter which records are returned using REDCap conditional syntax None date_begin Optional[datetime.datetime] Filter on records created after a date None date_end Optional[datetime.datetime] Filter on records created before a date None Returns: Type Description Union[List[Dict], str, pd.DataFrame] Exported data Examples: >>> proj . export_records () [{ 'record_id' : '1' , 'redcap_event_name' : 'event_1_arm_1' , 'field_1' : '1' , 'checkbox_field___1' : '0' , 'checkbox_field___2' : '1' , 'upload_field' : 'test_upload.txt' , 'form_1_complete' : '2' }, { 'record_id' : '2' , 'redcap_event_name' : 'event_1_arm_1' , 'field_1' : '0' , 'checkbox_field___1' : '0' , 'checkbox_field___2' : '0' , 'upload_field' : 'myupload.txt' , 'form_1_complete' : '0' }] >>> proj . export_records ( filter_logic = \"[field_1] = 1\" ) [{ 'record_id' : '1' , 'redcap_event_name' : 'event_1_arm_1' , 'field_1' : '1' , 'checkbox_field___1' : '0' , 'checkbox_field___2' : '1' , 'upload_field' : 'test_upload.txt' , 'form_1_complete' : '2' }] >>> proj . export_records ( ... format = \"csv\" , ... fields = [ \"field_1\" , \"checkbox_field\" ], ... raw_or_label = \"label\" ... ) 'field_1,checkbox_field___1,checkbox_field___2 \\n Yes,Unchecked,Checked \\n No,Unchecked,Unchecked \\n ' >>> import pandas as pd >>> pd . set_option ( \"display.max_columns\" , 3 ) >>> proj . export_records ( format = \"df\" ) field_1 ... form_1_complete record_id redcap_event_name ... 1 event_1_arm_1 1 ... 2 2 event_1_arm_1 0 ... 0 ... Source code in redcap/methods/records.py def export_records ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , records : Optional [ List [ str ]] = None , fields : Optional [ List [ str ]] = None , forms : Optional [ List [ str ]] = None , events : Optional [ List [ str ]] = None , raw_or_label : Literal [ \"raw\" , \"label\" , \"both\" ] = \"raw\" , event_name : Literal [ \"label\" , \"unique\" ] = \"label\" , type : Literal [ \"flat\" , \"eav\" ] = \"flat\" , export_survey_fields : bool = False , export_data_access_groups : bool = False , df_kwargs : Optional [ Dict ] = None , export_checkbox_labels : bool = False , filter_logic : Optional [ str ] = None , date_begin : Optional [ datetime ] = None , date_end : Optional [ datetime ] = None , ): \"\"\" Export data from the REDCap project. Args: format: Format of returned data. `'json'` returns json-decoded objects while `'csv'` and `'xml'` return other formats. `'df'` will attempt to return a `pandas.DataFrame` records: Array of record names specifying specific records to export. By default, all records are exported fields: Array of field names specifying specific fields to pull by default, all fields are exported forms: Array of form names to export. If in the web UI, the form name has a space in it, replace the space with an underscore By default, all forms are exported events: An array of unique event names from which to export records Note: This only applies to longitudinal projects raw_or_label: Export the raw coded values or labels for the options of multiple choice fields, or both event_name: Export the unique event name or the event label type: Database output structure type export_survey_fields: Specifies whether or not to export the survey identifier field (e.g., \"redcap_survey_identifier\") or survey timestamp fields (e.g., form_name+\"_timestamp\") when surveys are utilized in the project export_data_access_groups: Specifies whether or not to export the `\"redcap_data_access_group\"` field when data access groups are utilized in the project Note: This flag is only viable if the user whose token is being used to make the API request is *not* in a data access group. If the user is in a group, then this flag will revert to its default value. df_kwargs: Passed to `pandas.read_csv` to control construction of returned DataFrame. By default, `{'index_col': self.def_field}` export_checkbox_labels: Specify whether to export checkbox values as their label on export. filter_logic: Filter which records are returned using REDCap conditional syntax date_begin: Filter on records created after a date date_end: Filter on records created before a date Returns: Union[List[Dict], str, pd.DataFrame]: Exported data Examples: >>> proj.export_records() [{'record_id': '1', 'redcap_event_name': 'event_1_arm_1', 'field_1': '1', 'checkbox_field___1': '0', 'checkbox_field___2': '1', 'upload_field': 'test_upload.txt', 'form_1_complete': '2'}, {'record_id': '2', 'redcap_event_name': 'event_1_arm_1', 'field_1': '0', 'checkbox_field___1': '0', 'checkbox_field___2': '0', 'upload_field': 'myupload.txt', 'form_1_complete': '0'}] >>> proj.export_records(filter_logic=\"[field_1] = 1\") [{'record_id': '1', 'redcap_event_name': 'event_1_arm_1', 'field_1': '1', 'checkbox_field___1': '0', 'checkbox_field___2': '1', 'upload_field': 'test_upload.txt', 'form_1_complete': '2'}] >>> proj.export_records( ... format=\"csv\", ... fields=[\"field_1\", \"checkbox_field\"], ... raw_or_label=\"label\" ... ) 'field_1,checkbox_field___1,checkbox_field___2\\\\nYes,Unchecked,Checked\\\\nNo,Unchecked,Unchecked\\\\n' >>> import pandas as pd >>> pd.set_option(\"display.max_columns\", 3) >>> proj.export_records(format=\"df\") field_1 ... form_1_complete record_id redcap_event_name ... 1 event_1_arm_1 1 ... 2 2 event_1_arm_1 0 ... 0 ... \"\"\" # pylint: disable=line-too-long # pylint: enable=line-too-long ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( \"record\" , format = ret_format , rec_type = type ) keys_to_add = ( records , fields , forms , events , raw_or_label , event_name , export_survey_fields , export_data_access_groups , export_checkbox_labels , ) str_keys = ( \"records\" , \"fields\" , \"forms\" , \"events\" , \"rawOrLabel\" , \"eventName\" , \"exportSurveyFields\" , \"exportDataAccessGroups\" , \"exportCheckboxLabel\" , ) for key , data in zip ( str_keys , keys_to_add ): if data : if key in ( \"fields\" , \"records\" , \"forms\" , \"events\" ): for i , value in enumerate ( data ): payload [ f \" { key } [ { i } ]\" ] = value else : payload [ key ] = data if date_begin : payload [ \"dateRangeBegin\" ] = date_begin . strftime ( \"%Y-%m- %d %H:%M:%S\" ) if date_end : payload [ \"dateRangeEnd\" ] = date_end . strftime ( \"%Y-%m- %d %H:%M:%S\" ) if filter_logic : payload [ \"filterLogic\" ] = filter_logic response , _ = self . _call_api ( payload , \"exp_record\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : if type == \"eav\" : df_kwargs = {} else : if self . is_longitudinal : df_kwargs = { \"index_col\" : [ self . def_field , \"redcap_event_name\" ]} else : df_kwargs = { \"index_col\" : self . def_field } buf = StringIO ( response ) dataframe = self . _read_csv ( buf , ** df_kwargs ) buf . close () return dataframe","title":"export_records()"},{"location":"api_reference/records/#redcap.methods.records.Records.generate_next_record_name","text":"Get the next record name Returns: Type Description int The next record name for a project with auto-numbering records enabled Examples: >>> proj . generate_next_record_name () 3 Source code in redcap/methods/records.py def generate_next_record_name ( self ) -> int : \"\"\" Get the next record name Returns: The next record name for a project with auto-numbering records enabled Examples: >>> proj.generate_next_record_name() 3 \"\"\" payload = self . _basepl ( content = \"generateNextRecordName\" ) return self . _call_api ( payload , \"exp_next_id\" )[ 0 ]","title":"generate_next_record_name()"},{"location":"api_reference/records/#redcap.methods.records.Records.import_records","text":"Import data into the RedCap Project Parameters: Name Type Description Default to_import Union[str, List[Dict], pd.DataFrame] Note: If you pass a df, csv, or xml string, you should use the format parameter appropriately. Note: Keys of the dictionaries should be subset of project's, fields, but this isn't a requirement. If you provide keys that aren't defined fields, the returned response will contain an 'error' key. required return_format Literal['json', 'csv', 'xml'] Response format. By default, response will be json-decoded. 'json' overwrite Literal['normal', 'overwrite'] 'overwrite' will erase values previously stored in the database if not specified in the to_import dictionaries. 'normal' format Literal['json', 'csv', 'xml', 'df'] Format of incoming data. By default, to_import will be json-encoded 'json' return_content Literal['count', 'ids', 'nothing'] By default, the response contains a 'count' key with the number of records just imported. By specifying 'ids', a list of ids imported will be returned. 'nothing' will only return the HTTP status code and no message. 'count' date_format Literal['YMD', 'DMY', 'MDY'] Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. 'YMD' force_auto_number bool Enables automatic assignment of record IDs of imported records by REDCap. If this is set to true, and auto-numbering for records is enabled for the project, auto-numbering of imported records will be enabled. False Exceptions: Type Description RedcapError Bad request made, double check field names and inputs Returns: Type Description Union[Dict, str] response from REDCap API, json-decoded if return_format == 'json' Examples: >>> new_record = [{ \"record_id\" : 3 , \"field_1\" : 1 }] >>> proj . import_records ( new_record ) { 'count' : 1 } Source code in redcap/methods/records.py def import_records ( self , to_import : Union [ str , List [ Dict ], \"pd.DataFrame\" ], return_format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" , overwrite : Literal [ \"normal\" , \"overwrite\" ] = \"normal\" , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , return_content : Literal [ \"count\" , \"ids\" , \"nothing\" ] = \"count\" , date_format : Literal [ \"YMD\" , \"DMY\" , \"MDY\" ] = \"YMD\" , force_auto_number : bool = False , ): \"\"\" Import data into the RedCap Project Args: to_import: Note: If you pass a df, csv, or xml string, you should use the `format` parameter appropriately. Note: Keys of the dictionaries should be subset of project's, fields, but this isn't a requirement. If you provide keys that aren't defined fields, the returned response will contain an `'error'` key. return_format: Response format. By default, response will be json-decoded. overwrite: `'overwrite'` will erase values previously stored in the database if not specified in the to_import dictionaries. format: Format of incoming data. By default, to_import will be json-encoded return_content: By default, the response contains a 'count' key with the number of records just imported. By specifying 'ids', a list of ids imported will be returned. 'nothing' will only return the HTTP status code and no message. date_format: Describes the formatting of dates. By default, date strings are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date strings are formatted as 'MM/DD/YYYY' set this parameter as 'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No other formattings are allowed. force_auto_number: Enables automatic assignment of record IDs of imported records by REDCap. If this is set to true, and auto-numbering for records is enabled for the project, auto-numbering of imported records will be enabled. Raises: RedcapError: Bad request made, double check field names and inputs Returns: Union[Dict, str]: response from REDCap API, json-decoded if `return_format` == `'json'` Examples: >>> new_record = [{\"record_id\": 3, \"field_1\": 1}] >>> proj.import_records(new_record) {'count': 1} \"\"\" payload = self . _initialize_import_payload ( to_import , format , \"record\" ) payload [ \"overwriteBehavior\" ] = overwrite payload [ \"returnFormat\" ] = return_format payload [ \"returnContent\" ] = return_content payload [ \"dateFormat\" ] = date_format payload [ \"forceAutoNumber\" ] = force_auto_number response = self . _call_api ( payload , \"imp_record\" )[ 0 ] if \"error\" in response : raise RedcapError ( str ( response )) return response","title":"import_records()"},{"location":"api_reference/reports/","text":"Reports REDCap API methods for Project reports Reports ( Base ) Responsible for all API methods under 'Reports' in the API Playground Source code in redcap/methods/reports.py class Reports ( Base ): \"\"\"Responsible for all API methods under 'Reports' in the API Playground\"\"\" # pylint: disable=redefined-builtin # pylint: disable=too-many-locals @overload def export_report ( self , report_id : str , format : Literal [ \"json\" ], raw_or_label : Literal [ \"raw\" , \"label\" ] = \"raw\" , raw_or_label_headers : Literal [ \"raw\" , \"label\" ] = \"raw\" , export_checkbox_labels : bool = False , csv_delimiter : Literal [ \",\" , \"tab\" , \";\" , \"|\" , \"^\" ] = \",\" , df_kwargs : Optional [ Dict ] = None , ) -> List [ Dict ]: ... @overload def export_report ( self , report_id : str , format : Literal [ \"csv\" , \"xml\" ], raw_or_label : Literal [ \"raw\" , \"label\" ] = \"raw\" , raw_or_label_headers : Literal [ \"raw\" , \"label\" ] = \"raw\" , export_checkbox_labels : bool = False , csv_delimiter : Literal [ \",\" , \"tab\" , \";\" , \"|\" , \"^\" ] = \",\" , df_kwargs : Optional [ Dict ] = None , ) -> str : ... @overload def export_report ( self , report_id : str , format : Literal [ \"df\" ], raw_or_label : Literal [ \"raw\" , \"label\" ] = \"raw\" , raw_or_label_headers : Literal [ \"raw\" , \"label\" ] = \"raw\" , export_checkbox_labels : bool = False , csv_delimiter : Literal [ \",\" , \"tab\" , \";\" , \"|\" , \"^\" ] = \",\" , df_kwargs : Optional [ Dict ] = None , ) -> \"pd.DataFrame\" : ... def export_report ( self , report_id : str , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , raw_or_label : Literal [ \"raw\" , \"label\" ] = \"raw\" , raw_or_label_headers : Literal [ \"raw\" , \"label\" ] = \"raw\" , export_checkbox_labels : bool = False , csv_delimiter : Literal [ \",\" , \"tab\" , \";\" , \"|\" , \"^\" ] = \",\" , df_kwargs : Optional [ Dict ] = None , ): \"\"\" Export a report of the Project Args: report_id: The report ID number provided next to the report name on the report list page format: Format of returned data. `'json'` returns json-decoded objects while `'csv'` and `'xml'` return strings. `'df'` will attempt to return a `pandas.DataFrame`. raw_or_label: Export the raw coded values or labels for the options of multiple choice fields raw_or_label_headers: For the CSV headers, export the variable/field names (raw) or the field labels (label) export_checkbox_labels: Specifies the format of checkbox field values specifically when exporting the data as labels (i.e. when `rawOrLabel=label`). When exporting labels, by default (without providing the exportCheckboxLabel flag or if exportCheckboxLabel=false), all checkboxes will either have a value 'Checked' if they are checked or 'Unchecked' if not checked. But if exportCheckboxLabel is set to true, it will instead export the checkbox value as the checkbox option's label (e.g., 'Choice 1') if checked or it will be blank/empty (no value) if not checked csv_delimiter: For the csv format, choose how the csv delimiter. Raises: ValueError: Unsupported format specified Returns: Union[List[Dict], str, pd.DataFrame]: Data from the report ordered by the record (primary key of project) and then by event id Examples: >>> proj.export_report(report_id=\"4292\") # doctest: +SKIP [{'record_id': '1', 'redcap_event_name': 'event_1_arm_1', 'checkbox_field___1': '0', 'checkbox_field___2': '1'}] \"\"\" ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( content = \"report\" , format = ret_format ) keys_to_add = ( report_id , raw_or_label , raw_or_label_headers , export_checkbox_labels , csv_delimiter , ) str_keys = ( \"report_id\" , \"rawOrLabel\" , \"rawOrLabelHeaders\" , \"exportCheckboxLabel\" , \"csvDelimiter\" , ) for key , data in zip ( str_keys , keys_to_add ): if data : payload [ key ] = data response , _ = self . _call_api ( payload , \"exp_report\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : if self . is_longitudinal : df_kwargs = { \"index_col\" : [ self . def_field , \"redcap_event_name\" ]} else : df_kwargs = { \"index_col\" : self . def_field } buf = StringIO ( response ) dataframe = self . _read_csv ( buf , ** df_kwargs ) buf . close () return dataframe # pylint: enable=too-many-locals # pylint: enable=redefined-builtin def_field : str inherited property readonly The 'record_id' field equivalent for a project events : Optional [ List [ dict ]] inherited property readonly Project defined events !!! note Exists for longitudinal projects only field_names : List [ str ] inherited property readonly Project field names !!! note These are survey field names, not export field names is_longitudinal : bool inherited property readonly Whether or not this project is longitudinal metadata : List [ Dict [ str , str ]] inherited property readonly Project metadata in JSON format token : str inherited property readonly API token to your project url : str inherited property readonly API URL to your REDCap server export_report ( self , report_id , format = 'json' , raw_or_label = 'raw' , raw_or_label_headers = 'raw' , export_checkbox_labels = False , csv_delimiter = ',' , df_kwargs = None ) Export a report of the Project Parameters: Name Type Description Default report_id str The report ID number provided next to the report name on the report list page required format Literal['json', 'csv', 'xml', 'df'] Format of returned data. 'json' returns json-decoded objects while 'csv' and 'xml' return strings. 'df' will attempt to return a pandas.DataFrame . 'json' raw_or_label Literal['raw', 'label'] Export the raw coded values or labels for the options of multiple choice fields 'raw' raw_or_label_headers Literal['raw', 'label'] For the CSV headers, export the variable/field names (raw) or the field labels (label) 'raw' export_checkbox_labels bool Specifies the format of checkbox field values specifically when exporting the data as labels (i.e. when rawOrLabel=label ). When exporting labels, by default (without providing the exportCheckboxLabel flag or if exportCheckboxLabel=false), all checkboxes will either have a value 'Checked' if they are checked or 'Unchecked' if not checked. But if exportCheckboxLabel is set to true, it will instead export the checkbox value as the checkbox option's label (e.g., 'Choice 1') if checked or it will be blank/empty (no value) if not checked False csv_delimiter Literal[',', 'tab', ';', '|', '^'] For the csv format, choose how the csv delimiter. ',' Exceptions: Type Description ValueError Unsupported format specified Returns: Type Description Union[List[Dict], str, pd.DataFrame] Data from the report ordered by the record (primary key of project) and then by event id Examples: >>> proj . export_report ( report_id = \"4292\" ) # doctest: +SKIP [{ 'record_id' : '1' , 'redcap_event_name' : 'event_1_arm_1' , 'checkbox_field___1' : '0' , 'checkbox_field___2' : '1' }] Source code in redcap/methods/reports.py def export_report ( self , report_id : str , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , raw_or_label : Literal [ \"raw\" , \"label\" ] = \"raw\" , raw_or_label_headers : Literal [ \"raw\" , \"label\" ] = \"raw\" , export_checkbox_labels : bool = False , csv_delimiter : Literal [ \",\" , \"tab\" , \";\" , \"|\" , \"^\" ] = \",\" , df_kwargs : Optional [ Dict ] = None , ): \"\"\" Export a report of the Project Args: report_id: The report ID number provided next to the report name on the report list page format: Format of returned data. `'json'` returns json-decoded objects while `'csv'` and `'xml'` return strings. `'df'` will attempt to return a `pandas.DataFrame`. raw_or_label: Export the raw coded values or labels for the options of multiple choice fields raw_or_label_headers: For the CSV headers, export the variable/field names (raw) or the field labels (label) export_checkbox_labels: Specifies the format of checkbox field values specifically when exporting the data as labels (i.e. when `rawOrLabel=label`). When exporting labels, by default (without providing the exportCheckboxLabel flag or if exportCheckboxLabel=false), all checkboxes will either have a value 'Checked' if they are checked or 'Unchecked' if not checked. But if exportCheckboxLabel is set to true, it will instead export the checkbox value as the checkbox option's label (e.g., 'Choice 1') if checked or it will be blank/empty (no value) if not checked csv_delimiter: For the csv format, choose how the csv delimiter. Raises: ValueError: Unsupported format specified Returns: Union[List[Dict], str, pd.DataFrame]: Data from the report ordered by the record (primary key of project) and then by event id Examples: >>> proj.export_report(report_id=\"4292\") # doctest: +SKIP [{'record_id': '1', 'redcap_event_name': 'event_1_arm_1', 'checkbox_field___1': '0', 'checkbox_field___2': '1'}] \"\"\" ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( content = \"report\" , format = ret_format ) keys_to_add = ( report_id , raw_or_label , raw_or_label_headers , export_checkbox_labels , csv_delimiter , ) str_keys = ( \"report_id\" , \"rawOrLabel\" , \"rawOrLabelHeaders\" , \"exportCheckboxLabel\" , \"csvDelimiter\" , ) for key , data in zip ( str_keys , keys_to_add ): if data : payload [ key ] = data response , _ = self . _call_api ( payload , \"exp_report\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : if self . is_longitudinal : df_kwargs = { \"index_col\" : [ self . def_field , \"redcap_event_name\" ]} else : df_kwargs = { \"index_col\" : self . def_field } buf = StringIO ( response ) dataframe = self . _read_csv ( buf , ** df_kwargs ) buf . close () return dataframe","title":"Reports"},{"location":"api_reference/reports/#reports","text":"REDCap API methods for Project reports","title":"Reports"},{"location":"api_reference/reports/#redcap.methods.reports.Reports","text":"Responsible for all API methods under 'Reports' in the API Playground Source code in redcap/methods/reports.py class Reports ( Base ): \"\"\"Responsible for all API methods under 'Reports' in the API Playground\"\"\" # pylint: disable=redefined-builtin # pylint: disable=too-many-locals @overload def export_report ( self , report_id : str , format : Literal [ \"json\" ], raw_or_label : Literal [ \"raw\" , \"label\" ] = \"raw\" , raw_or_label_headers : Literal [ \"raw\" , \"label\" ] = \"raw\" , export_checkbox_labels : bool = False , csv_delimiter : Literal [ \",\" , \"tab\" , \";\" , \"|\" , \"^\" ] = \",\" , df_kwargs : Optional [ Dict ] = None , ) -> List [ Dict ]: ... @overload def export_report ( self , report_id : str , format : Literal [ \"csv\" , \"xml\" ], raw_or_label : Literal [ \"raw\" , \"label\" ] = \"raw\" , raw_or_label_headers : Literal [ \"raw\" , \"label\" ] = \"raw\" , export_checkbox_labels : bool = False , csv_delimiter : Literal [ \",\" , \"tab\" , \";\" , \"|\" , \"^\" ] = \",\" , df_kwargs : Optional [ Dict ] = None , ) -> str : ... @overload def export_report ( self , report_id : str , format : Literal [ \"df\" ], raw_or_label : Literal [ \"raw\" , \"label\" ] = \"raw\" , raw_or_label_headers : Literal [ \"raw\" , \"label\" ] = \"raw\" , export_checkbox_labels : bool = False , csv_delimiter : Literal [ \",\" , \"tab\" , \";\" , \"|\" , \"^\" ] = \",\" , df_kwargs : Optional [ Dict ] = None , ) -> \"pd.DataFrame\" : ... def export_report ( self , report_id : str , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , raw_or_label : Literal [ \"raw\" , \"label\" ] = \"raw\" , raw_or_label_headers : Literal [ \"raw\" , \"label\" ] = \"raw\" , export_checkbox_labels : bool = False , csv_delimiter : Literal [ \",\" , \"tab\" , \";\" , \"|\" , \"^\" ] = \",\" , df_kwargs : Optional [ Dict ] = None , ): \"\"\" Export a report of the Project Args: report_id: The report ID number provided next to the report name on the report list page format: Format of returned data. `'json'` returns json-decoded objects while `'csv'` and `'xml'` return strings. `'df'` will attempt to return a `pandas.DataFrame`. raw_or_label: Export the raw coded values or labels for the options of multiple choice fields raw_or_label_headers: For the CSV headers, export the variable/field names (raw) or the field labels (label) export_checkbox_labels: Specifies the format of checkbox field values specifically when exporting the data as labels (i.e. when `rawOrLabel=label`). When exporting labels, by default (without providing the exportCheckboxLabel flag or if exportCheckboxLabel=false), all checkboxes will either have a value 'Checked' if they are checked or 'Unchecked' if not checked. But if exportCheckboxLabel is set to true, it will instead export the checkbox value as the checkbox option's label (e.g., 'Choice 1') if checked or it will be blank/empty (no value) if not checked csv_delimiter: For the csv format, choose how the csv delimiter. Raises: ValueError: Unsupported format specified Returns: Union[List[Dict], str, pd.DataFrame]: Data from the report ordered by the record (primary key of project) and then by event id Examples: >>> proj.export_report(report_id=\"4292\") # doctest: +SKIP [{'record_id': '1', 'redcap_event_name': 'event_1_arm_1', 'checkbox_field___1': '0', 'checkbox_field___2': '1'}] \"\"\" ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( content = \"report\" , format = ret_format ) keys_to_add = ( report_id , raw_or_label , raw_or_label_headers , export_checkbox_labels , csv_delimiter , ) str_keys = ( \"report_id\" , \"rawOrLabel\" , \"rawOrLabelHeaders\" , \"exportCheckboxLabel\" , \"csvDelimiter\" , ) for key , data in zip ( str_keys , keys_to_add ): if data : payload [ key ] = data response , _ = self . _call_api ( payload , \"exp_report\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : if self . is_longitudinal : df_kwargs = { \"index_col\" : [ self . def_field , \"redcap_event_name\" ]} else : df_kwargs = { \"index_col\" : self . def_field } buf = StringIO ( response ) dataframe = self . _read_csv ( buf , ** df_kwargs ) buf . close () return dataframe # pylint: enable=too-many-locals # pylint: enable=redefined-builtin","title":"Reports"},{"location":"api_reference/reports/#redcap.methods.reports.Reports.def_field","text":"The 'record_id' field equivalent for a project","title":"def_field"},{"location":"api_reference/reports/#redcap.methods.reports.Reports.events","text":"Project defined events !!! note Exists for longitudinal projects only","title":"events"},{"location":"api_reference/reports/#redcap.methods.reports.Reports.field_names","text":"Project field names !!! note These are survey field names, not export field names","title":"field_names"},{"location":"api_reference/reports/#redcap.methods.reports.Reports.is_longitudinal","text":"Whether or not this project is longitudinal","title":"is_longitudinal"},{"location":"api_reference/reports/#redcap.methods.reports.Reports.metadata","text":"Project metadata in JSON format","title":"metadata"},{"location":"api_reference/reports/#redcap.methods.reports.Reports.token","text":"API token to your project","title":"token"},{"location":"api_reference/reports/#redcap.methods.reports.Reports.url","text":"API URL to your REDCap server","title":"url"},{"location":"api_reference/reports/#redcap.methods.reports.Reports.export_report","text":"Export a report of the Project Parameters: Name Type Description Default report_id str The report ID number provided next to the report name on the report list page required format Literal['json', 'csv', 'xml', 'df'] Format of returned data. 'json' returns json-decoded objects while 'csv' and 'xml' return strings. 'df' will attempt to return a pandas.DataFrame . 'json' raw_or_label Literal['raw', 'label'] Export the raw coded values or labels for the options of multiple choice fields 'raw' raw_or_label_headers Literal['raw', 'label'] For the CSV headers, export the variable/field names (raw) or the field labels (label) 'raw' export_checkbox_labels bool Specifies the format of checkbox field values specifically when exporting the data as labels (i.e. when rawOrLabel=label ). When exporting labels, by default (without providing the exportCheckboxLabel flag or if exportCheckboxLabel=false), all checkboxes will either have a value 'Checked' if they are checked or 'Unchecked' if not checked. But if exportCheckboxLabel is set to true, it will instead export the checkbox value as the checkbox option's label (e.g., 'Choice 1') if checked or it will be blank/empty (no value) if not checked False csv_delimiter Literal[',', 'tab', ';', '|', '^'] For the csv format, choose how the csv delimiter. ',' Exceptions: Type Description ValueError Unsupported format specified Returns: Type Description Union[List[Dict], str, pd.DataFrame] Data from the report ordered by the record (primary key of project) and then by event id Examples: >>> proj . export_report ( report_id = \"4292\" ) # doctest: +SKIP [{ 'record_id' : '1' , 'redcap_event_name' : 'event_1_arm_1' , 'checkbox_field___1' : '0' , 'checkbox_field___2' : '1' }] Source code in redcap/methods/reports.py def export_report ( self , report_id : str , format : Literal [ \"json\" , \"csv\" , \"xml\" , \"df\" ] = \"json\" , raw_or_label : Literal [ \"raw\" , \"label\" ] = \"raw\" , raw_or_label_headers : Literal [ \"raw\" , \"label\" ] = \"raw\" , export_checkbox_labels : bool = False , csv_delimiter : Literal [ \",\" , \"tab\" , \";\" , \"|\" , \"^\" ] = \",\" , df_kwargs : Optional [ Dict ] = None , ): \"\"\" Export a report of the Project Args: report_id: The report ID number provided next to the report name on the report list page format: Format of returned data. `'json'` returns json-decoded objects while `'csv'` and `'xml'` return strings. `'df'` will attempt to return a `pandas.DataFrame`. raw_or_label: Export the raw coded values or labels for the options of multiple choice fields raw_or_label_headers: For the CSV headers, export the variable/field names (raw) or the field labels (label) export_checkbox_labels: Specifies the format of checkbox field values specifically when exporting the data as labels (i.e. when `rawOrLabel=label`). When exporting labels, by default (without providing the exportCheckboxLabel flag or if exportCheckboxLabel=false), all checkboxes will either have a value 'Checked' if they are checked or 'Unchecked' if not checked. But if exportCheckboxLabel is set to true, it will instead export the checkbox value as the checkbox option's label (e.g., 'Choice 1') if checked or it will be blank/empty (no value) if not checked csv_delimiter: For the csv format, choose how the csv delimiter. Raises: ValueError: Unsupported format specified Returns: Union[List[Dict], str, pd.DataFrame]: Data from the report ordered by the record (primary key of project) and then by event id Examples: >>> proj.export_report(report_id=\"4292\") # doctest: +SKIP [{'record_id': '1', 'redcap_event_name': 'event_1_arm_1', 'checkbox_field___1': '0', 'checkbox_field___2': '1'}] \"\"\" ret_format = format if format == \"df\" : ret_format = \"csv\" payload = self . _basepl ( content = \"report\" , format = ret_format ) keys_to_add = ( report_id , raw_or_label , raw_or_label_headers , export_checkbox_labels , csv_delimiter , ) str_keys = ( \"report_id\" , \"rawOrLabel\" , \"rawOrLabelHeaders\" , \"exportCheckboxLabel\" , \"csvDelimiter\" , ) for key , data in zip ( str_keys , keys_to_add ): if data : payload [ key ] = data response , _ = self . _call_api ( payload , \"exp_report\" ) if format in ( \"json\" , \"csv\" , \"xml\" ): return response if format != \"df\" : raise ValueError ( f \"Unsupported format: ' { format } '\" ) if not df_kwargs : if self . is_longitudinal : df_kwargs = { \"index_col\" : [ self . def_field , \"redcap_event_name\" ]} else : df_kwargs = { \"index_col\" : self . def_field } buf = StringIO ( response ) dataframe = self . _read_csv ( buf , ** df_kwargs ) buf . close () return dataframe","title":"export_report()"},{"location":"api_reference/surveys/","text":"Surveys REDCap API methods for Project surveys Surveys ( Base ) Responsible for all API methods under 'Surveys' in the API Playground Source code in redcap/methods/surveys.py class Surveys ( Base ): \"\"\"Responsible for all API methods under 'Surveys' in the API Playground\"\"\" # pylint: disable=redefined-builtin @overload def export_survey_participant_list ( self , instrument : str , format : Literal [ \"json\" ], event : Optional [ str ] = None , ) -> List [ Dict ]: ... @overload def export_survey_participant_list ( self , instrument : str , format : Literal [ \"csv\" , \"xml\" ], event : Optional [ str ] = None , ) -> str : ... def export_survey_participant_list ( self , instrument : str , format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" , event : Optional [ str ] = None , ): \"\"\" Export the Survey Participant List Note: The passed instrument must be set up as a survey instrument. Args: instrument: Name of instrument as seen in the Data Dictionary (metadata). format: Format of returned data event: Unique event name, only used in longitudinal projects Returns: Union[List[Dict], str]: List of survey participants, along with other useful metadata such as the record, response status, etc. Examples: >>> proj.export_survey_participant_list(instrument=\"form_1\", event=\"event_1_arm_1\") [{'email': '', ... 'survey_access_code': ...}, {'email': '', ... 'survey_access_code': ...}] \"\"\" # pylint: disable=line-too-long # pylint: enable=line-too-long payload = self . _basepl ( content = \"participantList\" , format = format ) payload [ \"instrument\" ] = instrument if event : payload [ \"event\" ] = event return self . _call_api ( payload , \"exp_survey_participant_list\" )[ 0 ] # pylint: enable=redefined-builtin def_field : str inherited property readonly The 'record_id' field equivalent for a project events : Optional [ List [ dict ]] inherited property readonly Project defined events !!! note Exists for longitudinal projects only field_names : List [ str ] inherited property readonly Project field names !!! note These are survey field names, not export field names is_longitudinal : bool inherited property readonly Whether or not this project is longitudinal metadata : List [ Dict [ str , str ]] inherited property readonly Project metadata in JSON format token : str inherited property readonly API token to your project url : str inherited property readonly API URL to your REDCap server export_survey_participant_list ( self , instrument , format = 'json' , event = None ) Export the Survey Participant List !!! note The passed instrument must be set up as a survey instrument. Parameters: Name Type Description Default instrument str Name of instrument as seen in the Data Dictionary (metadata). required format Literal['json', 'csv', 'xml'] Format of returned data 'json' event Optional[str] Unique event name, only used in longitudinal projects None Returns: Type Description Union[List[Dict], str] List of survey participants, along with other useful metadata such as the record, response status, etc. Examples: >>> proj . export_survey_participant_list ( instrument = \"form_1\" , event = \"event_1_arm_1\" ) [{ 'email' : '' , ... 'survey_access_code' : ... }, { 'email' : '' , ... 'survey_access_code' : ... }] Source code in redcap/methods/surveys.py def export_survey_participant_list ( self , instrument : str , format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" , event : Optional [ str ] = None , ): \"\"\" Export the Survey Participant List Note: The passed instrument must be set up as a survey instrument. Args: instrument: Name of instrument as seen in the Data Dictionary (metadata). format: Format of returned data event: Unique event name, only used in longitudinal projects Returns: Union[List[Dict], str]: List of survey participants, along with other useful metadata such as the record, response status, etc. Examples: >>> proj.export_survey_participant_list(instrument=\"form_1\", event=\"event_1_arm_1\") [{'email': '', ... 'survey_access_code': ...}, {'email': '', ... 'survey_access_code': ...}] \"\"\" # pylint: disable=line-too-long # pylint: enable=line-too-long payload = self . _basepl ( content = \"participantList\" , format = format ) payload [ \"instrument\" ] = instrument if event : payload [ \"event\" ] = event return self . _call_api ( payload , \"exp_survey_participant_list\" )[ 0 ] # pylint: enable=redefined-builtin","title":"Surveys"},{"location":"api_reference/surveys/#surveys","text":"REDCap API methods for Project surveys","title":"Surveys"},{"location":"api_reference/surveys/#redcap.methods.surveys.Surveys","text":"Responsible for all API methods under 'Surveys' in the API Playground Source code in redcap/methods/surveys.py class Surveys ( Base ): \"\"\"Responsible for all API methods under 'Surveys' in the API Playground\"\"\" # pylint: disable=redefined-builtin @overload def export_survey_participant_list ( self , instrument : str , format : Literal [ \"json\" ], event : Optional [ str ] = None , ) -> List [ Dict ]: ... @overload def export_survey_participant_list ( self , instrument : str , format : Literal [ \"csv\" , \"xml\" ], event : Optional [ str ] = None , ) -> str : ... def export_survey_participant_list ( self , instrument : str , format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" , event : Optional [ str ] = None , ): \"\"\" Export the Survey Participant List Note: The passed instrument must be set up as a survey instrument. Args: instrument: Name of instrument as seen in the Data Dictionary (metadata). format: Format of returned data event: Unique event name, only used in longitudinal projects Returns: Union[List[Dict], str]: List of survey participants, along with other useful metadata such as the record, response status, etc. Examples: >>> proj.export_survey_participant_list(instrument=\"form_1\", event=\"event_1_arm_1\") [{'email': '', ... 'survey_access_code': ...}, {'email': '', ... 'survey_access_code': ...}] \"\"\" # pylint: disable=line-too-long # pylint: enable=line-too-long payload = self . _basepl ( content = \"participantList\" , format = format ) payload [ \"instrument\" ] = instrument if event : payload [ \"event\" ] = event return self . _call_api ( payload , \"exp_survey_participant_list\" )[ 0 ] # pylint: enable=redefined-builtin","title":"Surveys"},{"location":"api_reference/surveys/#redcap.methods.surveys.Surveys.def_field","text":"The 'record_id' field equivalent for a project","title":"def_field"},{"location":"api_reference/surveys/#redcap.methods.surveys.Surveys.events","text":"Project defined events !!! note Exists for longitudinal projects only","title":"events"},{"location":"api_reference/surveys/#redcap.methods.surveys.Surveys.field_names","text":"Project field names !!! note These are survey field names, not export field names","title":"field_names"},{"location":"api_reference/surveys/#redcap.methods.surveys.Surveys.is_longitudinal","text":"Whether or not this project is longitudinal","title":"is_longitudinal"},{"location":"api_reference/surveys/#redcap.methods.surveys.Surveys.metadata","text":"Project metadata in JSON format","title":"metadata"},{"location":"api_reference/surveys/#redcap.methods.surveys.Surveys.token","text":"API token to your project","title":"token"},{"location":"api_reference/surveys/#redcap.methods.surveys.Surveys.url","text":"API URL to your REDCap server","title":"url"},{"location":"api_reference/surveys/#redcap.methods.surveys.Surveys.export_survey_participant_list","text":"Export the Survey Participant List !!! note The passed instrument must be set up as a survey instrument. Parameters: Name Type Description Default instrument str Name of instrument as seen in the Data Dictionary (metadata). required format Literal['json', 'csv', 'xml'] Format of returned data 'json' event Optional[str] Unique event name, only used in longitudinal projects None Returns: Type Description Union[List[Dict], str] List of survey participants, along with other useful metadata such as the record, response status, etc. Examples: >>> proj . export_survey_participant_list ( instrument = \"form_1\" , event = \"event_1_arm_1\" ) [{ 'email' : '' , ... 'survey_access_code' : ... }, { 'email' : '' , ... 'survey_access_code' : ... }] Source code in redcap/methods/surveys.py def export_survey_participant_list ( self , instrument : str , format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" , event : Optional [ str ] = None , ): \"\"\" Export the Survey Participant List Note: The passed instrument must be set up as a survey instrument. Args: instrument: Name of instrument as seen in the Data Dictionary (metadata). format: Format of returned data event: Unique event name, only used in longitudinal projects Returns: Union[List[Dict], str]: List of survey participants, along with other useful metadata such as the record, response status, etc. Examples: >>> proj.export_survey_participant_list(instrument=\"form_1\", event=\"event_1_arm_1\") [{'email': '', ... 'survey_access_code': ...}, {'email': '', ... 'survey_access_code': ...}] \"\"\" # pylint: disable=line-too-long # pylint: enable=line-too-long payload = self . _basepl ( content = \"participantList\" , format = format ) payload [ \"instrument\" ] = instrument if event : payload [ \"event\" ] = event return self . _call_api ( payload , \"exp_survey_participant_list\" )[ 0 ] # pylint: enable=redefined-builtin","title":"export_survey_participant_list()"},{"location":"api_reference/users/","text":"Users REDCap API methods for Project users Users ( Base ) Responsible for all API methods under 'Users & User Privileges' in the API Playground Source code in redcap/methods/users.py class Users ( Base ): \"\"\"Responsible for all API methods under 'Users & User Privileges' in the API Playground\"\"\" # pylint: disable=redefined-builtin @overload def export_users ( self , format : Literal [ \"json\" ]) -> List [ Dict ]: ... @overload def export_users ( self , format : Literal [ \"csv\" , \"xml\" ]) -> str : ... def export_users ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" ): \"\"\" Export the users of the Project Note: Each user will have the following keys: * `'firstname'` : User's first name * `'lastname'` : User's last name * `'email'` : Email address * `'username'` : User's username * `'expiration'` : Project access expiration date * `'data_access_group'` : data access group ID * `'data_export'` : (0=no access, 2=De-Identified, 1=Full Data Set) * `'forms'` : a list of dicts with a single key as the form name and value is an integer describing that user's form rights, where: 0=no access, 1=view records/responses and edit records (survey responses are read-only), 2=read only, and 3=edit survey responses, Args: format: Response return format Returns: Union[List[Dict], str]: List of users with metadata Examples: >>> proj.export_users() [{'username': ..., 'email': ..., 'expiration': '', 'data_access_group': '', 'data_access_group_id': '', 'design': 1, 'user_rights': 1, 'data_access_groups': 1, 'data_export': 1, ...}] \"\"\" payload = self . _basepl ( content = \"user\" , format = format ) return self . _call_api ( payload , \"exp_user\" )[ 0 ] # pylint: enable=redefined-builtin def_field : str inherited property readonly The 'record_id' field equivalent for a project events : Optional [ List [ dict ]] inherited property readonly Project defined events !!! note Exists for longitudinal projects only field_names : List [ str ] inherited property readonly Project field names !!! note These are survey field names, not export field names is_longitudinal : bool inherited property readonly Whether or not this project is longitudinal metadata : List [ Dict [ str , str ]] inherited property readonly Project metadata in JSON format token : str inherited property readonly API token to your project url : str inherited property readonly API URL to your REDCap server export_users ( self , format = 'json' ) Export the users of the Project !!! note Each user will have the following keys: * `'firstname'` : User's first name * `'lastname'` : User's last name * `'email'` : Email address * `'username'` : User's username * `'expiration'` : Project access expiration date * `'data_access_group'` : data access group ID * `'data_export'` : (0=no access, 2=De-Identified, 1=Full Data Set) * `'forms'` : a list of dicts with a single key as the form name and value is an integer describing that user's form rights, where: 0=no access, 1=view records/responses and edit records (survey responses are read-only), 2=read only, and 3=edit survey responses, Parameters: Name Type Description Default format Literal['json', 'csv', 'xml'] Response return format 'json' Returns: Type Description Union[List[Dict], str] List of users with metadata Examples: >>> proj . export_users () [{ 'username' : ... , 'email' : ... , 'expiration' : '' , 'data_access_group' : '' , 'data_access_group_id' : '' , 'design' : 1 , 'user_rights' : 1 , 'data_access_groups' : 1 , 'data_export' : 1 , ... }] Source code in redcap/methods/users.py def export_users ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" ): \"\"\" Export the users of the Project Note: Each user will have the following keys: * `'firstname'` : User's first name * `'lastname'` : User's last name * `'email'` : Email address * `'username'` : User's username * `'expiration'` : Project access expiration date * `'data_access_group'` : data access group ID * `'data_export'` : (0=no access, 2=De-Identified, 1=Full Data Set) * `'forms'` : a list of dicts with a single key as the form name and value is an integer describing that user's form rights, where: 0=no access, 1=view records/responses and edit records (survey responses are read-only), 2=read only, and 3=edit survey responses, Args: format: Response return format Returns: Union[List[Dict], str]: List of users with metadata Examples: >>> proj.export_users() [{'username': ..., 'email': ..., 'expiration': '', 'data_access_group': '', 'data_access_group_id': '', 'design': 1, 'user_rights': 1, 'data_access_groups': 1, 'data_export': 1, ...}] \"\"\" payload = self . _basepl ( content = \"user\" , format = format ) return self . _call_api ( payload , \"exp_user\" )[ 0 ] # pylint: enable=redefined-builtin","title":"Users"},{"location":"api_reference/users/#users","text":"REDCap API methods for Project users","title":"Users"},{"location":"api_reference/users/#redcap.methods.users.Users","text":"Responsible for all API methods under 'Users & User Privileges' in the API Playground Source code in redcap/methods/users.py class Users ( Base ): \"\"\"Responsible for all API methods under 'Users & User Privileges' in the API Playground\"\"\" # pylint: disable=redefined-builtin @overload def export_users ( self , format : Literal [ \"json\" ]) -> List [ Dict ]: ... @overload def export_users ( self , format : Literal [ \"csv\" , \"xml\" ]) -> str : ... def export_users ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" ): \"\"\" Export the users of the Project Note: Each user will have the following keys: * `'firstname'` : User's first name * `'lastname'` : User's last name * `'email'` : Email address * `'username'` : User's username * `'expiration'` : Project access expiration date * `'data_access_group'` : data access group ID * `'data_export'` : (0=no access, 2=De-Identified, 1=Full Data Set) * `'forms'` : a list of dicts with a single key as the form name and value is an integer describing that user's form rights, where: 0=no access, 1=view records/responses and edit records (survey responses are read-only), 2=read only, and 3=edit survey responses, Args: format: Response return format Returns: Union[List[Dict], str]: List of users with metadata Examples: >>> proj.export_users() [{'username': ..., 'email': ..., 'expiration': '', 'data_access_group': '', 'data_access_group_id': '', 'design': 1, 'user_rights': 1, 'data_access_groups': 1, 'data_export': 1, ...}] \"\"\" payload = self . _basepl ( content = \"user\" , format = format ) return self . _call_api ( payload , \"exp_user\" )[ 0 ] # pylint: enable=redefined-builtin","title":"Users"},{"location":"api_reference/users/#redcap.methods.users.Users.def_field","text":"The 'record_id' field equivalent for a project","title":"def_field"},{"location":"api_reference/users/#redcap.methods.users.Users.events","text":"Project defined events !!! note Exists for longitudinal projects only","title":"events"},{"location":"api_reference/users/#redcap.methods.users.Users.field_names","text":"Project field names !!! note These are survey field names, not export field names","title":"field_names"},{"location":"api_reference/users/#redcap.methods.users.Users.is_longitudinal","text":"Whether or not this project is longitudinal","title":"is_longitudinal"},{"location":"api_reference/users/#redcap.methods.users.Users.metadata","text":"Project metadata in JSON format","title":"metadata"},{"location":"api_reference/users/#redcap.methods.users.Users.token","text":"API token to your project","title":"token"},{"location":"api_reference/users/#redcap.methods.users.Users.url","text":"API URL to your REDCap server","title":"url"},{"location":"api_reference/users/#redcap.methods.users.Users.export_users","text":"Export the users of the Project !!! note Each user will have the following keys: * `'firstname'` : User's first name * `'lastname'` : User's last name * `'email'` : Email address * `'username'` : User's username * `'expiration'` : Project access expiration date * `'data_access_group'` : data access group ID * `'data_export'` : (0=no access, 2=De-Identified, 1=Full Data Set) * `'forms'` : a list of dicts with a single key as the form name and value is an integer describing that user's form rights, where: 0=no access, 1=view records/responses and edit records (survey responses are read-only), 2=read only, and 3=edit survey responses, Parameters: Name Type Description Default format Literal['json', 'csv', 'xml'] Response return format 'json' Returns: Type Description Union[List[Dict], str] List of users with metadata Examples: >>> proj . export_users () [{ 'username' : ... , 'email' : ... , 'expiration' : '' , 'data_access_group' : '' , 'data_access_group_id' : '' , 'design' : 1 , 'user_rights' : 1 , 'data_access_groups' : 1 , 'data_export' : 1 , ... }] Source code in redcap/methods/users.py def export_users ( self , format : Literal [ \"json\" , \"csv\" , \"xml\" ] = \"json\" ): \"\"\" Export the users of the Project Note: Each user will have the following keys: * `'firstname'` : User's first name * `'lastname'` : User's last name * `'email'` : Email address * `'username'` : User's username * `'expiration'` : Project access expiration date * `'data_access_group'` : data access group ID * `'data_export'` : (0=no access, 2=De-Identified, 1=Full Data Set) * `'forms'` : a list of dicts with a single key as the form name and value is an integer describing that user's form rights, where: 0=no access, 1=view records/responses and edit records (survey responses are read-only), 2=read only, and 3=edit survey responses, Args: format: Response return format Returns: Union[List[Dict], str]: List of users with metadata Examples: >>> proj.export_users() [{'username': ..., 'email': ..., 'expiration': '', 'data_access_group': '', 'data_access_group_id': '', 'design': 1, 'user_rights': 1, 'data_access_groups': 1, 'data_export': 1, ...}] \"\"\" payload = self . _basepl ( content = \"user\" , format = format ) return self . _call_api ( payload , \"exp_user\" )[ 0 ] # pylint: enable=redefined-builtin","title":"export_users()"},{"location":"api_reference/version/","text":"Version REDCap API methods for Project REDCap version Version ( Base ) Responsible for all API methods under 'REDCap' in the API Playground Source code in redcap/methods/version.py class Version ( Base ): \"\"\"Responsible for all API methods under 'REDCap' in the API Playground\"\"\" def export_version ( self ) -> Optional [ semantic_version . Version ]: \"\"\" Get the REDCap version Returns: REDCap version running on the url provided Examples: >>> import semantic_version >>> redcap_version = proj.export_version() >>> assert redcap_version >= semantic_version.Version(\"12.0.1\") \"\"\" payload = self . _basepl ( \"version\" ) redcap_version = self . _call_api ( payload , \"version\" )[ 0 ] . decode ( \"utf-8\" ) resp : Optional [ semantic_version . Version ] = None if \"error\" in redcap_version : warnings . warn ( \"Version information not available for this REDCap instance\" ) if semantic_version . validate ( redcap_version ): resp = semantic_version . Version ( redcap_version ) return resp def_field : str inherited property readonly The 'record_id' field equivalent for a project events : Optional [ List [ dict ]] inherited property readonly Project defined events !!! note Exists for longitudinal projects only field_names : List [ str ] inherited property readonly Project field names !!! note These are survey field names, not export field names is_longitudinal : bool inherited property readonly Whether or not this project is longitudinal metadata : List [ Dict [ str , str ]] inherited property readonly Project metadata in JSON format token : str inherited property readonly API token to your project url : str inherited property readonly API URL to your REDCap server export_version ( self ) Get the REDCap version Returns: Type Description Optional[semantic_version.base.Version] REDCap version running on the url provided Examples: >>> import semantic_version >>> redcap_version = proj . export_version () >>> assert redcap_version >= semantic_version . Version ( \"12.0.1\" ) Source code in redcap/methods/version.py def export_version ( self ) -> Optional [ semantic_version . Version ]: \"\"\" Get the REDCap version Returns: REDCap version running on the url provided Examples: >>> import semantic_version >>> redcap_version = proj.export_version() >>> assert redcap_version >= semantic_version.Version(\"12.0.1\") \"\"\" payload = self . _basepl ( \"version\" ) redcap_version = self . _call_api ( payload , \"version\" )[ 0 ] . decode ( \"utf-8\" ) resp : Optional [ semantic_version . Version ] = None if \"error\" in redcap_version : warnings . warn ( \"Version information not available for this REDCap instance\" ) if semantic_version . validate ( redcap_version ): resp = semantic_version . Version ( redcap_version ) return resp","title":"Version"},{"location":"api_reference/version/#version","text":"REDCap API methods for Project REDCap version","title":"Version"},{"location":"api_reference/version/#redcap.methods.version.Version","text":"Responsible for all API methods under 'REDCap' in the API Playground Source code in redcap/methods/version.py class Version ( Base ): \"\"\"Responsible for all API methods under 'REDCap' in the API Playground\"\"\" def export_version ( self ) -> Optional [ semantic_version . Version ]: \"\"\" Get the REDCap version Returns: REDCap version running on the url provided Examples: >>> import semantic_version >>> redcap_version = proj.export_version() >>> assert redcap_version >= semantic_version.Version(\"12.0.1\") \"\"\" payload = self . _basepl ( \"version\" ) redcap_version = self . _call_api ( payload , \"version\" )[ 0 ] . decode ( \"utf-8\" ) resp : Optional [ semantic_version . Version ] = None if \"error\" in redcap_version : warnings . warn ( \"Version information not available for this REDCap instance\" ) if semantic_version . validate ( redcap_version ): resp = semantic_version . Version ( redcap_version ) return resp","title":"Version"},{"location":"api_reference/version/#redcap.methods.version.Version.def_field","text":"The 'record_id' field equivalent for a project","title":"def_field"},{"location":"api_reference/version/#redcap.methods.version.Version.events","text":"Project defined events !!! note Exists for longitudinal projects only","title":"events"},{"location":"api_reference/version/#redcap.methods.version.Version.field_names","text":"Project field names !!! note These are survey field names, not export field names","title":"field_names"},{"location":"api_reference/version/#redcap.methods.version.Version.is_longitudinal","text":"Whether or not this project is longitudinal","title":"is_longitudinal"},{"location":"api_reference/version/#redcap.methods.version.Version.metadata","text":"Project metadata in JSON format","title":"metadata"},{"location":"api_reference/version/#redcap.methods.version.Version.token","text":"API token to your project","title":"token"},{"location":"api_reference/version/#redcap.methods.version.Version.url","text":"API URL to your REDCap server","title":"url"},{"location":"api_reference/version/#redcap.methods.version.Version.export_version","text":"Get the REDCap version Returns: Type Description Optional[semantic_version.base.Version] REDCap version running on the url provided Examples: >>> import semantic_version >>> redcap_version = proj . export_version () >>> assert redcap_version >= semantic_version . Version ( \"12.0.1\" ) Source code in redcap/methods/version.py def export_version ( self ) -> Optional [ semantic_version . Version ]: \"\"\" Get the REDCap version Returns: REDCap version running on the url provided Examples: >>> import semantic_version >>> redcap_version = proj.export_version() >>> assert redcap_version >= semantic_version.Version(\"12.0.1\") \"\"\" payload = self . _basepl ( \"version\" ) redcap_version = self . _call_api ( payload , \"version\" )[ 0 ] . decode ( \"utf-8\" ) resp : Optional [ semantic_version . Version ] = None if \"error\" in redcap_version : warnings . warn ( \"Version information not available for this REDCap instance\" ) if semantic_version . validate ( redcap_version ): resp = semantic_version . Version ( redcap_version ) return resp","title":"export_version()"}]}